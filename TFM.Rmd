---
title: "TFM"
author: "Diana Campos López"
date: "2025-03-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Dependencies

```{r, library, message=FALSE, warning=FALSE}
library(maftools)
library(readxl)
library(ggplot2)
library(dplyr)
library(GenomicRanges)
library(data.table)
library(circlize)
library(scales)
library(ComplexHeatmap)
library(tidyr)
library(patchwork)
library(stringr)
library(ggrepel) 
library(tidyverse)
library(VariantAnnotation)
library(DESeq2)
library(tibble)
library(clusterProfiler)
library(org.Hs.eg.db)
library(enrichplot)
library(readr)
library(survival)
library(survminer)
library(signatureSearch)
library(survival)
library(forestplot)
library(magrittr)
library(broom)

```

# 0. Data analysis

```{r}
# Import Clinical Data & Remove Last 9 Rows
clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized.txt"
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)

# Remove last 9 rows
clinical_data <- clinical_data[1:(nrow(clinical_data) - 9), ]

#  Compute Proportions for Different Clinical Features
calculate_proportions <- function(data, column) {
  data %>%
    count(!!sym(column)) %>%
    mutate(Proportion = n / sum(n) * 100)
}

responder_prop <- calculate_proportions(clinical_data, "response_TAC1")
wes_prop <- clinical_data %>%
  mutate(WES_available = ifelse(WES_FFPE_sampleName != "", "Has WES", "No WES")) %>%
  calculate_proportions("WES_available")

wes_responder_prop <- clinical_data %>%
  filter(WES_FFPE_sampleName != "") %>%
  calculate_proportions("response_TAC1")

smoking_prop <- clinical_data %>%
  mutate(smoking_status = ifelse(smoking_status == "" | is.na(smoking_status), "Unknown", smoking_status)) %>%
  calculate_proportions("smoking_status")

stage_distribution <- clinical_data %>%
  mutate(stage = ifelse(stage == "" | is.na(stage), "Unknown", stage)) %>%
  calculate_proportions("stage")

sex_distribution <- calculate_proportions(clinical_data, "sex")

exitus_prop <- clinical_data %>%
  calculate_proportions("exitus")


print("Proportion of Responders vs. Non-Responders:")
print(responder_prop)

print("Proportion of Patients with WES:")
print(wes_prop)

print("Proportion of Responders and Non-Responders within WES patients:")
print(wes_responder_prop)

print("Smoking Status Distribution:")
print(smoking_prop)

print("Cancer Stage Distribution:")
print(stage_distribution)

print("Sex Distribution:")
print(sex_distribution)

print("Exitus (Survival) Distribution:")
print(exitus_prop)

```


# Objective 1: To obtain the mutational and expression profiles of genes involved in the maintenance of the m6A mark in RCC patients

## 1. To identify the variants in the genes belonging to the m6A machinery

### 1.1. Filter potential artifacts and low quality variants

Primero descargamos los datos MAF y realizamos las transformaciones necesarias. Necesitamos asignar un ID distinto a cada mutación para poder diferenciarlas, ya que los pacientes pueden tener mutaciones distintas en las mismas regiones y hay que diferenciarlas.



```{r}
# Definir variantes no sinónimas
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

# Lista de archivos MAF
maf_files <- list.files(path = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Mutect2_tumorOnly_variantCalling_hg38", 
                        pattern = "\\.PASS_annotated\\.maf$", full.names = TRUE)

# Definir el archivo de salida. He quitado este codigo porque no me va a dejar leerlo por ser muy pesado. Uso un documento intermedio pero despues de los filtros.
output_maf <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_variants_2.maf"
if (file.exists(output_maf)) file.remove(output_maf)

# Crear una lista para almacenar los datos
maf_list <- list()

# Leer y almacenar cada archivo MAF
for (file in maf_files) {
  print(paste("Procesando:", file))
  
  maf_obj <- tryCatch({
    read.maf(file, vc_nonSyn = vc_nonsyn)
  }, error = function(e) {
    message(paste("Error al leer:", file, "-", e$message))
    return(NULL)
  })
  
  if (!is.null(maf_obj)) {
    maf_data <- maf_obj@data
    
    # Verificar que no haya pérdida de columnas
    if (ncol(maf_data) > 0) {
      maf_list[[file]] <- maf_data
    }
  }
}

# Fusionar todos los archivos en un solo dataframe
if (length(maf_list) > 0) {
  all_samples <- bind_rows(maf_list)  # Unir todos los MAFs sin perder columnas
  
  print("¡MAF fusionado guardado correctamente!")
} else {
  print("⚠️ No se han podido leer archivos MAF correctamente.")
}

# Eliminamos todoo menos maf_data_all
rm(list = setdiff(ls(), "all_samples"))

#añadimos los ID

all_samples$variantID <- paste0(all_samples$Chromosome, ':',
                                all_samples$Start_Position, '-',
                                all_samples$End_Position, '_',
                                all_samples$Reference_Allele, '>',
                                all_samples$Tumor_Seq_Allele2, '_',
                                all_samples$Strand, '|', 
                                all_samples$Hugo_Symbol, '_', 
                                all_samples$HGVSc, '_',
                                all_samples$HGVSp, '_',
                                all_samples$Tumor_Sample_Barcode)

all_samples$variantID_noSample <- paste0(all_samples$Chromosome, ':',
                                         all_samples$Start_Position, '-',
                                         all_samples$End_Position, '_',
                                         all_samples$Reference_Allele, '>',
                                         all_samples$Tumor_Seq_Allele2, '_',
                                         all_samples$Strand, '|',
                                         all_samples$Hugo_Symbol, '_',
                                         all_samples$HGVSc, '_',
                                         all_samples$HGVSp)

```

Con este codigo obtenemos en el entorno un df all_samples completo. 

En segundo lugar descargamos de las base de datos las regiones conflictivas. 

a) sites present in the NCBI track dbVar Curated Common SVs Conflicts with Pathogenic (DbVarConflict) of hg38 genome

```
https://genome.ucsc.edu/cgi-bin/hgTables?hgsid=2482102181_ndDykqHxoIXdXrpVmAxVodXE6ptW&clade=mammal&org=&db=hg38&hgta_group=varRep&hgta_track=dbVar_conflict&hgta_table=dbVar_conflict_pathogenic&hgta_regionType=genome&position=&hgta_outputType=primaryTable&hgta_outFileName=dbVar_Conflict_SV.bed
```

b) variants present in the regions of the ENCODE blacklist subtrack, which contains a set of problematic regions due to a high ratio of multi-mapping to unique mapping reads and high variance in mappability due to repetitive elements

```
https://genome.ucsc.edu/cgi-bin/hgTables?hgsid=2482102181_ndDykqHxoIXdXrpVmAxVodXE6ptW&clade=mammal&org=Human&db=hg38&hgta_group=map&hgta_track=problematic&hgta_table=encBlacklist&hgta_regionType=genome&position=chr7%3A155%2C799%2C529-155%2C812%2C871&hgta_outputType=primaryTable&hgta_outFileName=ENCODE_blacklist_hg38.bed
```

c) sites present in the database of fragile sites in human chromosomes (HumCFS)
He añadido un header con los nombres para que mantenga el mismo formato que los demas.

``` 
https://webs.iiitd.edu.in/raghava/humcfs/download.html
```

d) variants overlapping with the Genome-In-A-Bottle (GIAB) giabCallConflict track set

```
https://genome.ucsc.edu/cgi-bin/hgTables?hgsid=2480133759_SXHhHB4HyEncmYlu8slT0Bhd2caS&clade=mammal&org=Human&db=hg38&hgta_group=map&hgta_track=problematicGIAB&hgta_table=alldifficultregions&hgta_regionType=genome&position=chr7%3A155%2C799%2C529-155%2C812%2C871&hgta_outputType=bed&hgta_outFileName=fragile_sites
```

```{r, conflicting regions}
#a)
dbVarConflict <- read.delim("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/dbVar_Conflict_SV.bed", header = T)
dbVarConflict <- dbVarConflict[,1:3]

#b)
encodeBlacklist <- read.delim('D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/ENCODE_blacklist_hg38.bed', header = T)
encodeBlacklist <- encodeBlacklist[,1:3]

#c)
fragileSites <- read.delim('D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/HumCFS_fragile_sites_hg38.bed', header = T)
fragileSites <- fragileSites[,1:3]

#d)
giabCallConflict <- read.delim('D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/GIAB_call_conflict.bed', header = T)
giabCallConflict <- giabCallConflict[,1:3]

# Unimos y transformar a GRanges 

conflictRegions <- as.data.frame(rbind(dbVarConflict, 
                                       encodeBlacklist, 
                                       fragileSites,
                                       giabCallConflict))

# He cambiado el nombre de las variantes y eliminado chr para poder eliminarlo de los mafs

colnames(conflictRegions) <- c("Chromosome", "Start_Position", "End_Position")
conflictRegions$Chromosome <- gsub("chr", "", conflictRegions$Chromosome)


conflictRegionsRanges <- GRanges(seqnames=conflictRegions$Chromosome,
                                 ranges=paste(conflictRegions$Start_Position,
                                              conflictRegions$End_Position,
                                              sep='-'))
```


```{r, Filtering}
# Convertir all_samples a GRanges para comparación
tumorVariantsRanges <- GRanges(seqnames=all_samples$Chromosome,
                               ranges=paste(all_samples$Start_Position,
             all_samples$End_Position,
             sep='-'))

# Encontrar variantes que se solapan con regiones conflictivas
hits <- findOverlaps(tumorVariantsRanges, conflictRegionsRanges)

# Obtener índices de variantes conflictivas
conflictiveVariants <- queryHits(hits)

# Eliminar variantes conflictivas
allNonConflictive_data <- all_samples[-conflictiveVariants, ]

```

```{r, filtering artifacts}
artifacts <- read.delim('D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/ProbableArtifacts.tsv', header=F, sep=' ')

# No tenia añadido el ShortVariantID 
allNonConflictive_data$shortVariantID <-
  paste0(allNonConflictive_data$Chromosome,':',
         allNonConflictive_data$Start_Position, '-',                                    allNonConflictive_data$End_Position, '_',                                      allNonConflictive_data$Reference_Allele, '>',                                  allNonConflictive_data$Tumor_Seq_Allele2)

artifactsindata <- allNonConflictive_data$shortVariantID %in% artifacts$V1

allNonConflictive_data <- allNonConflictive_data[!(artifactsindata),]

# Cargamos los variantes del PON de GAKT
vcf <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/somatic-hg38-af-only-gnomad.hg38.noChr.MT_filteredMAF10.vcf", sep='\t', header = TRUE, skip = '#CHROM')

vcf<- vcf[, .(ALT = unlist(strsplit(ALT, ","))), 
                    by = .(`#CHROM`, POS, ID, REF)]
vcf[, vcf_filter := paste0(`#CHROM`, ":", POS, "_", REF, "/", ALT)]

allNonConflictive_data <-fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.tsv")

allNonConflictive_data$vcfVariantID <-
  paste0(allNonConflictive_data$Chromosome,':',
         allNonConflictive_data$Start_Position, '_',                                      allNonConflictive_data$Reference_Allele, '/',                                    allNonConflictive_data$Tumor_Seq_Allele2)



allNonConflictive_data <- allNonConflictive_data %>%
  filter(!vcfVariantID %in% vcf$vcf_filter)

# Guardamos en formato .tsv
write.table(filtered, 'D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.tsv', sep='\t', col.names=T, row.names=F, quote=F)

# Guardamos en formato MAF
write.table(allNonConflictive_data, 
            file = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.maf",
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
```



En la siguiente celda podemos eliminar el entorno de R salvo allNonConflictive_data. Si lo hemos ruenado previamente y tenemos el archivo descargado, podemos simplemente leer  el archivo allVariants en lugar de runear el codigo.

```{r}
rm(list = setdiff(ls(), "allNonConflictive_data"))
```


### 1.2. Describe the mutational profile of the m6A machinery in RCC patients

Si no quiere runear el codigo anterior para conseguir el archivo, puede utilizar este codigo para cargar el tsv que incluye los datos clinicos y las variantes filtradas previamente y añadimos los datos clinicos para realizar hisgogramas: 

```{r}
allNonConflictive_data <-fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.tsv")
```


```{r}
# Añadimos los datos clinicos
clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized.txt"
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)

allNonConflictive_data <- left_join(allNonConflictive_data, clinical_data, by = "Tumor_Sample_Barcode")

rm(list = setdiff(ls(), "allNonConflictive_data"))
```


Para calcular las frecuencias alelicas usamos este codigo: 

```{r}
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Variants_Histograms_raw.png", width = 1500, height = 1000, res = 300)
ggplot(allNonConflictive_data, aes(x = t_AF)) +
  geom_histogram(binwidth = 0.05, fill = "indianred1", color = "black", alpha = 0.5) +
  labs(title = "Allele Frequencies Distribution",
       x = "Allele Frequencies",
       y = "Variants Number") +
  theme_minimal()
dev.off()
```

Nos han salido dos picos muy altos en 0.5 y 0.7. Primero creamos en este paso los subset de mafs y probamos distintos filtos seleccionando finalmente: 

```{r}
# Substed y carga de MAFs 
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

merged_data <- read.maf(maf = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.maf", vc_nonSyn = vc_nonsyn )

merged_data <- subsetMaf(maf=merged_data, query="t_depth > 10 & t_alt_count > 3 & Variant_Classification != 'Intron'")

write.table(merged_data@data, 
            file = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.maf",
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# Filtramos los genes de m6A 
epitranscriptomic_genes <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/epitranscriptomic_regulators_annotated.txt", 
                                 sep = "\t", header = TRUE)
m6A_genes <- epitranscriptomic_genes %>%
  filter(Mark == "m6A") %>%
  pull(Gene_symbol)

m6A_data <- merged_data@data %>%
  filter(Hugo_Symbol %in% m6A_genes)

# Modificamos el nombre de Tumor_Sample_Barcode para que esté mas corto

m6A_data$Tumor_Sample_Barcode <- gsub("WES_FFPE_", "", m6A_data$Tumor_Sample_Barcode)

# Guardamos en .tsv y en .maf  
write.table(m6A_data, 'D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A.tsv', sep='\t', col.names=T, row.names=F, quote=F)
write.table(m6A_data, 
            file = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A.maf",
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

merged_data.maf tiene guardados los filtros tdepth taltcount y no intron, mientras que all_non_conflictive_data no los tiene.

```{r}
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

merged_data <- read.maf(maf = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.maf", vc_nonSyn = vc_nonsyn )


# Crear histograma
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Variants_Histograms.png", width = 2000, height = 1000, res = 300)
ggplot(merged_data@data, aes(x = t_AF)) +
  geom_histogram(binwidth = 0.05, fill = "indianred1", color = "black", alpha = 0.7) +
  labs(title = "Allele Frequencies Distribution",
       x = "Allele Frequencies",
       y = "Variants Number") +
  theme_minimal()
dev.off()
```

Código histogramas de cantidad de variaciones: 

```{r}
# Ensure missing values are correctly labeled
allNonConflictive_data <- allNonConflictive_data %>%
  mutate(
    smoking_status = ifelse(smoking_status == "" | is.na(smoking_status), "Unknown", smoking_status),
    sex = ifelse(sex == "" | is.na(sex), "Unknown", sex),
    response_TAC1 = ifelse(is.na(response_TAC1) | response_TAC1 == "", "Unknown", response_TAC1),
    stage = ifelse(stage == "" | is.na(stage), "Unknown", stage)
  )

# Variants per Sample by Smoking Status
variant_counts_smoking <- allNonConflictive_data %>%
  count(sample_ID, smoking_status) %>%
  arrange(desc(n))

p1 <- ggplot(variant_counts_smoking, aes(x = reorder(sample_ID, -n), y = n, fill = smoking_status)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) +
  scale_fill_manual(values = c("never_smoker" = "blue", "smoker" = "red", "former_smoker" = "orange", "Unknown" = "gray")) +
  labs(title = "Variants per Sample by Smoking Status", x = "Sample ID", y = "Number of Variants", fill = "Smoking Status") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14),
        legend.position = "bottom")

# Variants per Sample by Sex
variant_counts_sex <- allNonConflictive_data %>%
  count(sample_ID, sex) %>%
  arrange(desc(n))

p2 <- ggplot(variant_counts_sex, aes(x = reorder(sample_ID, -n), y = n, fill = sex)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) +
  scale_fill_manual(values = c("male" = "orchid1", "female" = "skyblue1", "Unknown" = "gray")) +
  labs(title = "Variants per Sample by Sex", x = "Sample ID", y = "Number of Variants", fill = "Sex") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14),
        legend.position = "bottom")

# Variants per Sample by Response to Treatment
variant_counts_response <- allNonConflictive_data %>%
  count(sample_ID, response_TAC1) %>%
  arrange(desc(n))

p3 <- ggplot(variant_counts_response, aes(x = reorder(sample_ID, -n), y = n, fill = response_TAC1)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) +
  scale_fill_manual(values = c("responder" = "lightgreen", "non_responder" = "indianred1", "Unknown" = "gray")) +
  labs(title = "Variants per Sample by Response", x = "Sample ID", y = "Number of Variants", fill = "Response TAC1") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14),
        legend.position = "bottom")

# Variants per Sample by Tumor Stage
variant_counts_stage <- allNonConflictive_data %>%
  count(sample_ID, stage) %>%
  arrange(desc(n))

p4 <- ggplot(variant_counts_stage, aes(x = reorder(sample_ID, -n), y = n, fill = stage)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) +
  scale_fill_manual(values = c("I" = "lightgreen", "II" = "skyblue", "III" = "orange", "IV" = "indianred1", "Unknown" = "gray")) +
  labs(title = "Variants per Sample by Tumor Stage", x = "Sample ID", y = "Number of Variants", fill = "Tumor Stage") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14),
        legend.position = "bottom")

# Export all plots in one PNG file (2x2 layout)
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Variants_Histograms.png", width = 4000, height = 3000, res = 300)
gridExtra::grid.arrange(p3, p2, p4, p1, ncol = 2)
dev.off()

```


```{r}
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

merged_data <- read.maf(maf = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/merged_data.maf", vc_nonSyn = vc_nonsyn )

# ──────────────────────────────────────────────────────
# Preparar datos con conteo de variantes por muestra
# ──────────────────────────────────────────────────────
variant_counts <- merged_data@data %>%
  count(Tumor_Sample_Barcode, name = "num_variants")

# Juntar con datos clínicos
variant_counts <- variant_counts %>%
  left_join(clinical_data, by = c("Tumor_Sample_Barcode" = "Sample")) %>%
  mutate(
    response_TAC1 = ifelse(is.na(response_TAC1) | response_TAC1 == "", "Unknown", response_TAC1),
    sex = ifelse(is.na(sex) | sex == "", "Unknown", sex),
    stage = ifelse(stage == "" | is.na(stage), "Unknown", stage),
    age_group = ifelse(age > 63, "old", "young"),
    age_group = factor(age_group, levels = c("young", "old"))
  )

# ──────────────────────────────────────────────────────
# Boxplot por respuesta al tratamiento
# ──────────────────────────────────────────────────────
p_resp <- ggplot(variant_counts, aes(x = response_TAC1, y = num_variants, fill = response_TAC1)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("responder" = "lightgreen", "non_responder" = "indianred1", "Unknown" = "gray")) +
  labs(title = "Variants per Sample by Response", x = "Response", y = "Number of Variants") +
  theme_minimal()

# ──────────────────────────────────────────────────────
# Boxplot por sexo
# ──────────────────────────────────────────────────────
p_sex <- ggplot(variant_counts, aes(x = sex, y = num_variants, fill = sex)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("male" = "orchid1", "female" = "skyblue1", "Unknown" = "gray")) +
  labs(title = "Variants per Sample by Sex", x = "Sex", y = "Number of Variants") +
  theme_minimal()

# ──────────────────────────────────────────────────────
# Boxplot por etapa tumoral (solo III vs IV)
# ──────────────────────────────────────────────────────
p_stage <- variant_counts %>%
  filter(stage %in% c("III", "IV")) %>%
  ggplot(aes(x = stage, y = num_variants, fill = stage)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("III" = "orange", "IV" = "indianred1")) +
  labs(title = "Variants per Sample by Tumor Stage (III vs IV)", x = "Stage", y = "Number of Variants") +
  theme_minimal()

# ──────────────────────────────────────────────────────
# Boxplot por grupo de edad
# ──────────────────────────────────────────────────────
p_age <- ggplot(variant_counts, aes(x = age_group, y = num_variants, fill = age_group)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = c("young" = "skyblue", "old" = "darkorange")) +
  labs(title = "Variants per Sample by Age Group", x = "Age Group", y = "Number of Variants") +
  theme_minimal()

# ──────────────────────────────────────────────────────
# Exportar los 4 gráficos en un PNG (2x2 layout)
# ──────────────────────────────────────────────────────
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Boxplots_Variants_by_Clinical.png", width = 4000, height = 3000, res = 300)
gridExtra::grid.arrange(p_resp, p_sex, p_stage, p_age, ncol = 2)
dev.off()

```

Para el oncoplot usamos el .maf con sus datos clinicos

```{r}
# Cargar el archivo
maf_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A.maf"
clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized_maf.txt"
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

# Leer los datos
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)

# Convertir el archivo TSV en un objeto MAF sin guardarlo
m6A_maf <- read.maf(maf = maf_path, clinicalData = clinical_data, vc_nonSyn = vc_nonsyn)

```

Código oncoplot:

```{r}

# Filtro para que el oncoplot no este con mucho ruido
m6A_oncoplot <- subsetMaf(maf=m6A_maf,
query="t_AF >= 0.1 & t_depth > 10 & IMPACT != 'LOW' & Consequence != 'synonymous_variant' & Variant_Classification != 'Silent' & 
                                  Variant_Classification != 'Intron'")
# Guardamos
write.table(m6A_oncoplot@data, 
            file = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A_filtered.maf",
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)


# Definir colores oncoplot
color.palette <- list(
  smoking_status = c("smoker" = "red", 
                     "former_smoker" = "orange", 
                     "never_smoker" = "blue", 
                     "Unknown" = "gray"),
  response_TAC1 = c("responder" = "green", 
                    "non_responder" = "red", 
                    "Unknown" = "gray"),
  sex = c("female" = "skyblue",
          "male" = "coral1")
)

# Oncoplot
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/perfil_mut.png", width = 5000, height = 5000, res = 300)

oncoplot(maf = m6A_oncoplot, 
         top = 50,  
         draw_titv = TRUE,  
         clinicalFeatures = c("response_TAC1", "smoking_status", "sex"),  
         annotationColor = color.palette,
         sortByAnnotation = TRUE, 
         fontSize = 0.8,
         showTumorSampleBarcodes = TRUE,
         legendFontSize = 3,  
         annotationFontSize = 3,
         titleFontSize = 3)  

dev.off()

```

```{r}
# Cargar el archivo TSV
maf_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A.maf"
clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized_maf.txt"
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

# Leer los datos
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)
clinical_data <- clinical_data %>%
  mutate(smoking_status = as.character(smoking_status)) %>%
  mutate(smoking_status = ifelse(is.na(smoking_status) | smoking_status == "", "Unknown", smoking_status)) %>%
  mutate(smoking_status = factor(smoking_status, levels = c("smoker", "former_smoker", "never_smoker", "Unknown")))


# Convertir el archivo TSV en un objeto MAF sin guardarlo
m6A_maf <- read.maf(maf = maf_path, clinicalData = clinical_data, vc_nonSyn = vc_nonsyn)



m6A_maf@clinical.data$smoking_status <- factor(
  m6A_maf@clinical.data$smoking_status,
  levels = c("smoker", "former_smoker", "never_smoker", "Unknown")
)

# Definir colores oncoplot
color.palette <- list(
  smoking_status = c("smoker" = "red", 
                     "former_smoker" = "orange", 
                     "never_smoker" = "blue", 
                     "Unknown" = "gray"),
  response_TAC1 = c("responder" = "green", 
                    "non_responder" = "red"),
  sex = c("female" = "skyblue",
          "male" = "coral1")
)

# Oncoplot
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/perfil_mut_sf.png", width = 3000, height = 3000, res = 300)

oncoplot(maf = m6A_maf, 
         top = 50,  
         draw_titv = TRUE,  
         clinicalFeatures = c("response_TAC1", "smoking_status", "sex"),  
         annotationColor = color.palette,
         sortByAnnotation = TRUE, 
         fontSize = 0.8,
         showTumorSampleBarcodes = TRUE,
         legendFontSize = 1.5,  
         annotationFontSize = 1.5,
         titleFontSize = 1.5,
         titleText = "Oncoplot of m6A machinery genes. Altered in 16 of 18 patients (88.89%)")  

dev.off()

```



## 2. To obtain the expression levels of the genes belonging to the m6A machinery

### 2.1. Quality control of gene expression


a) Filter expression = 0

```{r}

# Cargar los archivos de expresión RNA-seq
rna_seq_files <- list.files(path = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/HTseq_expression_hg38", 
                            pattern = "\\.tsv$", full.names = TRUE)

# Leer y combinar los archivos
rna_seq_list <- lapply(rna_seq_files, function(file) {
  df <- read.delim(file, header = FALSE, stringsAsFactors = FALSE) 
  df$Sample <- basename(file)  # Añadir el nombre de la muestra como columna
  return(df)
})

# Unir todas las tablas en un solo dataframe
rna_seq_data <- bind_rows(rna_seq_list)
colnames(rna_seq_data) <- c("gene_id", "Gene", "Expression", "Sample")

rna_seq_data$gene_id <- str_remove(rna_seq_data$gene_id, "\\..*")

# Filtrar los genes cuya expresión no sea 0 en todas las muestras
rna_expression_all <- rna_seq_data %>%
  group_by(Gene) %>%
  filter(any(Expression != 0)) %>% 
  ungroup()

```



### 2.2. Get the FPKM and TPM expression levels of the m6A machinery genes for each patient

a) Calculate TPM and FPKM and separate m6a expression

```{r}
# Cargar el archivo sin encabezado
gene_lengths <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/featureLengths_hg38.tsv", 
                      header = FALSE, sep = "\t")

# Renombrar columnas manualmente
colnames(gene_lengths) <- c("gene_id", "gene_length", "Col3", "Col4", "Col5", "hgnc_id")

# Limpiar 'gene_id' eliminando "gene_id " y el contenido después del punto "."
gene_lengths$gene_id <- gsub('^gene_id "\\s*|"$', "", gene_lengths$gene_id)
gene_lengths <- gene_lengths %>%
  mutate(gene_id = str_remove(gene_id, "\\..*")) %>%  
  dplyr::select(gene_id, gene_length)

# Unir la expresión con la longitud de los genes
rna_expression_all <- rna_expression_all %>%
  left_join(gene_lengths, by = "gene_id")

# Eliminar valores NA en 'gene_length' para evitar errores en los cálculos
rna_expression_all <- rna_expression_all %>%
  filter(!is.na(gene_length) & gene_length > 0)

# **Calcular Total_reads antes de calcular FPKM**
total_reads_per_sample <- rna_expression_all %>%
  group_by(Sample) %>%
  summarise(Total_reads = sum(Expression))  # Suma de todas las expresiones por muestra

# Unir Total_reads al dataframe principal
rna_expression_all <- rna_expression_all %>%
  left_join(total_reads_per_sample, by = "Sample")

# **Calcular FPKM**
rna_expression_all <- rna_expression_all %>%
  mutate(FPKM = (Expression / gene_length) / (Total_reads / 1e6))

# **Calcular TPM**
sum_FPKM_per_sample <- rna_expression_all %>%
  group_by(Sample) %>%
  summarise(Sum_FPKM = sum(FPKM))  # Sumar todos los FPKM por muestra

# Unir Sum_FPKM al dataframe principal
rna_expression_all <- rna_expression_all %>%
  left_join(sum_FPKM_per_sample, by = "Sample") %>%
  mutate(TPM = (FPKM / Sum_FPKM) * 1e6)

# **Añadir los datos clínicos**
clinical_data <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized.txt", 
                       sep = "\t", header = TRUE)

# Limpiar nombres de muestra en el RNA-seq
rna_expression_all$Sample <- gsub("htseq-", "", rna_expression_all$Sample)
rna_expression_all$Sample <- gsub(".tsv", "", rna_expression_all$Sample)

# Unir datos clínicos
merged_rna_clinical <- rna_expression_all %>%
  left_join(clinical_data, by = c("Sample" = "RNA_FFPE_sampleName"))
  
```


```{r, Solo m6A}
# Seleccionar genes de m6A
epitranscriptomic_genes <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/epitranscriptomic_regulators_annotated.txt", 
                                 sep = "\t", header = TRUE)

m6A_genes <- epitranscriptomic_genes %>%
  filter(Mark == "m6A") %>%
  pull(Gene_symbol)

# Filtrar solo genes de la maquinaria m6A
rna_m6a_expression <- merged_rna_clinical %>%
  filter(Gene %in% m6A_genes)



```

b) Grafiqueamos los boxplot

```{r, boxplot TPM}
### RAW BOXPLOT ###
# Ensure response_TAC1 is a factor
merged_rna_clinical$response_TAC1 <- factor(merged_rna_clinical$response_TAC1, levels = c("responder", "non_responder"))

# Create the boxplot
p1 <- ggplot(merged_rna_clinical, aes(x = reorder(Sample, Expression, median), y = Expression, fill = response_TAC1)) +
  geom_boxplot(alpha = 0.7) +  # Remove outliers
  scale_y_log10() +  
  scale_fill_manual(values = c("responder" = "lightgreen", "non_responder" = "indianred1")) +  # Custom colors
  labs(title = "Raw Gene Expression",
       x = "Patient Sample",
       y = "Gene Expression (log10)",
       fill = "Response Type") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14))

# Export as PNG
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/raw_Histograms.png", width = 1000, height = 1000, res = 150)
print(p1)  
dev.off()

### TPM AND FPKM BOXTPLOT ###
p2 <- ggplot(merged_rna_clinical, aes(x = reorder(Sample, Expression, median), y = TPM, fill = response_TAC1)) +
  geom_boxplot(alpha = 0.7) + 
  scale_y_log10() +  # Log-transform
  scale_fill_manual(values = c("responder" = "lightgreen", "non_responder" = "indianred1")) +  # Custom colors
  labs(title = "TPM Distribution Per Sample",
       x = "Patient Sample",
       y = "Gene Expression (log10)",
       fill = "Response Type") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14))

p3 <- ggplot(merged_rna_clinical, aes(x = reorder(Sample, Expression, median), y = FPKM, fill = response_TAC1)) +
  geom_boxplot(alpha = 0.7) +
  scale_y_log10() +  # Log-transform
  scale_fill_manual(values = c("responder" = "lightgreen", "non_responder" = "indianred1")) +  # Custom colors
  labs(title = "FPKM Distribution Per Sample",
       x = "Patient Sample",
       y = "Gene Expression (log10)",
       fill = "Response Type") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.title = element_text(size = 14))

# Export as PNG
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/TPM_FPKM_Histograms.png", width = 2000, height = 1000, res = 150)
print(p2 | p3)  
dev.off()


```
```{r}
# Librerías necesarias
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)

# Función para convertir listas a su media
limpiar_matriz <- function(df) {
  df %>%
    mutate(across(everything(), ~ {
      if (is.list(.)) {
        sapply(., function(x) mean(unlist(x), na.rm = TRUE))
      } else {
        as.numeric(.)
      }
    }))
}

# Construcción de matrices
tpm_matrix <- rna_expression_all %>%
  dplyr::select(Sample, Gene, TPM) %>%
  pivot_wider(names_from = Gene, values_from = TPM) %>%
  drop_na()

fpkm_matrix <- rna_expression_all %>%
   dplyr::select(Sample, Gene, FPKM) %>%
  pivot_wider(names_from = Gene, values_from = FPKM) %>%
  drop_na()

raw_matrix <- rna_expression_all %>%
   dplyr::select(Sample, Gene, Expression) %>%
  pivot_wider(names_from = Gene, values_from = Expression) %>%
  drop_na()

tpm_m6a_matrix <- rna_m6a_expression %>%
   dplyr::select(Sample, Gene, TPM) %>%
  pivot_wider(names_from = Gene, values_from = TPM) %>%
  drop_na()

```


```{r}
# Matriz RAW
expr_matrix_raw <- raw_matrix %>%
  column_to_rownames("Sample")

# Convertir listas a medias
expr_matrix_raw <- expr_matrix_raw %>%
  mutate(across(everything(), ~ {
    if (is.list(.)) {
      sapply(., function(x) mean(unlist(x), na.rm = TRUE))
    } else {
      as.numeric(.)
    }
  }))

# PCA
pca_raw <- prcomp(expr_matrix_raw, scale. = TRUE)

# DataFrame PCA
pca_df_raw <- as.data.frame(pca_raw$x)
pca_df_raw$Sample <- rownames(pca_df_raw)

# Unión con datos clínicos
pca_raw_merged <- left_join(pca_df_raw, merged_rna_clinical, by = "Sample")

# Gráfico
ggplot(pca_raw_merged, aes(x = PC1, y = PC2, color = response_TAC1)) +
  geom_point(size = 3, alpha = 0.8) +
  labs(title = "PCA - Raw Expression", x = "PC1", y = "PC2") +
  theme_minimal()

```


```{r, heatmap}

# Replace zeros with NA to avoid log-scale issues
rna_m6a_expression <- rna_m6a_expression %>%
  mutate(TPM = ifelse(TPM == 0, NA, TPM),
         FPKM = ifelse(FPKM == 0, NA, FPKM))

# TPM Heatmap Preparation
rna_m6a_matrix <- rna_m6a_expression %>%
  dplyr::select(Sample, Gene, TPM) %>%
  spread(Sample, TPM)  

# Convert to matrix & keep `sample_ID`
rownames(rna_m6a_matrix) <- rna_m6a_matrix$gene_name  # Keep gene names
rna_m6a_matrix <- as.matrix(rna_m6a_matrix[,-1])  

# Normalize expression (Z-score per gene)
rna_m6a_matrix_scaled <- t(scale(t(rna_m6a_matrix)))  

# Clinical Annotations (Including `sample_ID`)
annotation_col <- merged_rna_clinical %>%
  dplyr::select(Sample, sample_ID, response_TAC1, sex, smoking_status) %>%
  distinct() 

# Set `Sample` as rownames for heatmap annotations
rownames(annotation_col) <- annotation_col$Sample  
annotation_col <- annotation_col %>% dplyr::select(-Sample)  

# 🔹 **Define annotation colors**
ann_colors <- list(
  response_TAC1 = c("responder" = "green", "non_responder" = "red"),
  sex = c("male" = "lightcoral", "female" = "lightgreen"),
  smoking_status = c("never_smoker" = "blue", "smoker" = "brown", "former_smoker" = "orange", "NA" = "lightgrey")
)


# Save TPM Heatmap as PNG
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/m6A_Heatmap.png", width = 2000, height = 1500, res = 150)
Heatmap(
  rna_m6a_matrix_scaled,  
  name = "TPM",
  color = colorRamp2(c(-4, 0, 4), c("blue", "white", "red")), 
  top_annotation = HeatmapAnnotation(df = annotation_col, col = ann_colors),
  show_row_names = TRUE,  # Show gene names
  show_column_names = TRUE,  # **Now showing sample_ID**
  column_title = "TPM Heatmap with Clinical Annotations",
  clustering_distance_rows = "euclidean",
  clustering_distance_columns = "euclidean"
)
dev.off()

```

## 3. To evaluate if the somatic mutations have an effect on gene expression

### 3.1. Select variants with a predicted effect at protein level (missense, truncating, frameshift and/or splice variants)

Cargamos el archivo si no esta cargado

```{r}
# Cargar el archivo TSV
maf_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A.maf"
clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized_maf.txt"
vc_nonsyn <- c("Targeted_Region", "Splice_Site", "Nonsense_Mutation", 
               "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation", 
               "Translation_Start_Site", "In_Frame_Ins", "In_Frame_Del", 
               "Missense_Mutation", "Intron", "Splice_Region", "Silent", 
               "RNA", "5'UTR", "3'UTR", "IGR", "5'Flank", "3'Flank")

# Leer los datos
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)


m6A_maf <- read.maf(maf = maf_path, clinicalData = clinical_data, vc_nonSyn = vc_nonsyn)
```

Seleccionamos las variantes que afectan a la proteina 
```{r}
# Define mutations that affect protein function
protein_effect_mutations <- c("Missense_Mutation", 
                              "Nonsense_Mutation", 
                              "Frame_Shift_Del", 
                              "Frame_Shift_Ins", 
                              "Splice_Site")

# Filter m6A mutations based on effect
m6A_protein_effect_mutations <- subsetMaf(maf = m6A_maf, 
                                          query = paste0("Variant_Classification %in% c('",                                                  paste(protein_effect_mutations, collapse = "','"), 
                                                         "')"))

write.table(m6A_protein_effect_mutations@data, 
            file = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/m6A_proteffect.maf",
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
```


realizamos un oncoplot
```{r}
# he utilizado la modificacion de la chunk 17 para el oncoplot para que se vea unknown en la leyenda

# Definir colores oncoplot
color.palette <- list(
  smoking_status = c("smoker" = "red", 
                     "former_smoker" = "orange", 
                     "never_smoker" = "blue", 
                     "Unknown" = "gray"),
  response_TAC1 = c("responder" = "green", 
                    "non_responder" = "red", 
                    "Unknown" = "gray"),
  sex = c("female" = "skyblue",
          "male" = "coral1")
)

# Oncoplot
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/perfil_mut_proteffect.png", width = 2000, height = 2000, res = 300)

oncoplot(maf = m6A_protein_effect_mutations, 
         top = 52,  
         draw_titv = TRUE,  
         clinicalFeatures = c("response_TAC1", "smoking_status", "sex"),  
         annotationColor = color.palette,
         sortByAnnotation = TRUE, 
         fontSize = 0.8,
         showTumorSampleBarcodes = TRUE,
         legendFontSize = 1,  
         annotationFontSize = 1,
         titleFontSize = 1,
          titleText = "Oncoplot of m6A machinery genes variant with a protein effect. Altered in 9 of 18 patients (50%)") 

dev.off()
```


```{r}
m6A_mutation_dataset <- m6A_protein_effect_mutations@data %>%
  dplyr::select(Hugo_Symbol,           
                Tumor_Sample_Barcode,  
                Variant_Classification, 
                PolyPhen,               
                SIFT,   
                IMPACT
  
  )

```


PolyPhen
probably damaging (PR): It is with high confidence supposed to affect protein function or structure
possibly damaging (PO): It is supposed to affect protein function or structure
benign (BE): Most likely lacking any phenotypic effect
unknown (UN): When in some rare cases, the lack of data does not allow PolyPhen to make a prediction


SIFT
tolerated: Not likely to have a phenotypic effect
tolerated_low_confidence: More likely to have a phenotypic effect than 'tolerated'
deleterious: Likely to have a phenotypic effect
deleterious_low_confidence: Less likely to have a phenotypic effect than 'deleterious'

```{r}
# Filtrado estricto: TODAS las condiciones deben cumplirse
pathogenic <- subsetMaf(
  maf = m6A_protein_effect_mutations,
  query = "(IMPACT != 'LOW') &
           (is.na(gnomAD_AF) | gnomAD_AF < 0.01)"
)

# Oncoplot
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/perfil_mut_pathogenic.png", width = 2000, height = 2000, res = 300)

oncoplot(maf = pathogenic, 
         top = 52,  
         draw_titv = TRUE,  
         clinicalFeatures = c("response_TAC1", "smoking_status", "sex"),  
         annotationColor = color.palette,
         sortByAnnotation = TRUE, 
         fontSize = 0.8,
         showTumorSampleBarcodes = TRUE,
         legendFontSize = 1,  
         annotationFontSize = 1,
         titleFontSize = 1,
          titleText = "Oncoplot of m6A machinery genes variant with a protein effect. Altered in 7 of 18 patients (38.89%)") 

dev.off()


write.table(pathogenic@data,
            file = "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/pathogenic_m6A_variants.tsv",
            sep = "\t",
            row.names = FALSE,
            col.names = TRUE,
            quote = FALSE)

```



### 3.2. Evaluate how the mutational status of the m6A machinery affect the expression of epitranscriptomic signatures (GOBP_MRNA_MODIFICATION, GOBP_RNA_MODIFICATION)

Ir a chunk 18 y 19 y subir los datos.

He tenido muchos errores debido a que algunos grupos de genes pacientes estan repes. concretamente 47890 de 48115 son unicos, y el resto aparecen mas de una vez por paciente:


```{r}
merged_rna_clinical %>%
  dplyr::group_by(Gene, Sample) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
  dplyr::filter(n > 1)
```

```{r}
unique_gene_sample_counts <- merged_rna_clinical %>%
  group_by(Gene, Sample) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n == 1) %>%                 # Solo combinaciones únicas
  count(Sample, name = "unique_genes") 

print(unique_gene_sample_counts)

```
 Lo he solucionado creando una funcion que calcule la media para esas expresiones repes.

sacar la firma de todas las muestras de rna y seq. 

ver si hay mutaciones en la maquinaria cambia la actividad epitranscriptomica del tumor. eso se puede ver con lae pxresion entonces me quedo con las rna seq y exoma. saco el valor de las firmas en todas las muestras y ahcer un heatmap y en anotaciones poner si responden o no y el estado de la mutacion 
al paquetue GSVVA le meto los tpm y mis firmas. las firmas se sacande una lista y todos los genes de esa lista y me saca el score para esa. 

en GSEA msigdb puedo buscar firmas pero es un poco dificil. Estabilidad del mensajero. buscar mrna stability/ degradacion etc.

```{r}
# Define gene sets
gobp_rna_mod <- c("METTL15P1", "ADAR", "ADARB1", "EMG1", "ADARB2", "WDR4", "APOBEC2", "DUS4L", "WDR6", "KTI12", "RPUSD1", "HENMT1", "BUD23","TRMT61A", "TSR3", "FTSJ3", "MTFMT", "PUSL1", "TYW3", "TYW5", "METTL6", "ADAD1", "ADAT2", "APOBEC3D", "TRUB1", "BCDIN3D", "B3GNTL1", "PUS10", "TRMT44", "NSUN5P1", "TRMT10B", "AARS1", "ADAD2", "APOBEC3H", "DKC1", "TRDMT1", "METTL15", "APOBEC3A", "APOBEC3F", "AKT1", "FBL", "NSUN6", "JMJD6", "ELP5", "FTSJ1", "MTO1", "THUMPD3", "VIRMA", "NSUN5P2", "ELP4", "TRUB2", "RPUSD2", "DIMT1", "MOCS3", "APOBEC3C", "RPUSD3", "DPH3", "DTWD2", "ZCCHC4", "METTL5", "RBM15B", "MRM2", "A1CF", "HSD17B10", "HNRNPAB", "APOBEC1", "METTL2A", "FBLL1", "CTU2", "RAMACL", "NSUN4", "METTL1", "TYW1B", "NOP2", "PARN", "TPRKB", "SEPSECS", "METTL25B", "TFB1M", "TRMT112","TRMO", "LARP7", "TRMT6", "CDK5RAP1", "DNAJB11", "GAR1", "TRMT13", "RBM47", "PUS7", "ANKRD16", "TRIT1", "ELP6", "NSUN2", "CDKAL1", "DUS2", "TRMT10C", "THG1L", "TRMT61B", "TRMT12", "ELP3", "DALRD3", "MRM3", "NAT10", "ELP2", "TYW1", "NOP10", "TRMT1", "THUMPD1", "OSGEP", "NHP2", "TRMU", "NSUN5", "METTL2B", "MEPCE", "METTL3", "DUS3L", "DTWD1", "AICDA", "TRMT5", "TRMT9B", "METTL14", "APOBEC3G", "SARS1", "THADA", "NSUN3", "DUS1L", "OSGEPL1", "TFB2M", "RBM15", "METTL4", "SNRPB", "SNRPD1", "SNRPD2", "SNRPD3", "SNRPE", "SNRPF", "SNRPG", "SSB", "TARBP1", "METTL16", "QTRT2", "YRDC", "GTDC1", "METTL8", "MRM1", "TRMT2B", "PUS1", "THUMPD2", "URM1", "TRMT1L", "QTRT1", "PUS7L", "PUS3", "RAMAC", "QNG1", "GON7", "GTPBP3", "RPUSD4", "ELP1", "RNMT", "ALKBH1", "CTU1", "ALKBH8", "FDXACB1", "NAF1", "TRMT10A", "BAG4", "APOBEC3B", "WTAP", "TGS1", "LCMT2")

gobp_mrna_mod <- c("APOBEC2", "TRUB1", "DKC1", "VIRMA", "TRUB2", "RPUSD2", "A1CF", "HNRNPAB", "APOBEC1", "DNAJB11", "PUS7", "METTL3", "METTL14", "METTL4", "PUS1", "PUS7L", "PUS3", "RPUSD4", "BAG4", "WTAP")

GOBP_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY <- c("PATL2", "CNOT1", "CNOT6L", "PAN3", "CNOT2", "NBDY", "CNOT6", "PAN2")

GOBP_POSITIVE_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY <- c("CNOT1", "CNOT6L", "PAN3", "CNOT2", "CNOT6", "PAN2")

GOCC_P_BODY <- c("HAX1", "IGF2BP1", "IGF2BP3", "IGF2BP2", "PNRC1", "RBPMS", "LSM6", "WTIP", "DIS3L2", "TRIM71", "APOBEC3D", "RC3H1", "APOBEC3H", "DDX6", "DCP2", "AGO3", "AGO4", "DCP1B", "PATL2", "EIF4E", "ELAVL1", "APOBEC3A", "APOBEC3F", "C9orf72", "PATL1", "CNOT1", "SAMD4A", "TNRC6B", "SYNE1", "CARHSP1", "EDC4", "YTHDF3", "PAN3", "LSM4", "NOCT", "LSM14A", "AGO1", "AGO2", "LSM1", "LSM3", "TNRC6A", "APOBEC3C", "DCPS", "CNOT7", "NANOS2", "ZC3H12D", "NANOS3", "ISG20", "CAPRIN1", "MOV10", "CNOT2", "CNOT3", "YBX1", "YTHDF2", "BTBD1", "POLR2G", "XRN1", "RC3H2", "YTHDF1", "NBDY", "SAMD4B", "SHFL", "PNRC2", "BTBD2", "DCP1A", "UBAP2", "EIF4ENIF1", "PSMA2", "PSMA4", "PSMA6", "PSMC2", "PSMC3", "AICDA", "TNRC6C", "LSM2","UPF1", "APOBEC3G", "CPEB1", "TRIM21", "ZFP36L1", "TOP1", "ZFP36", "CSDE1", "FAM184A", "LIN28A", "ZC3H12A", "EDC3", "MEX3B", "AJUBA", "TRIM5", "SQSTM1", "LIMD1", "CNOT9", "MEX3A", "CNOT8", "EIF4E2", "APOBEC3B", "PUM1", "GARRE1", "PAN2")

GOBP_MIRNA_PROCESSING <- c("ZMPSTE24", "ADAR", "TRIM71", "TRUB1", "BCDIN3D", "PUS10", "DDX5", "AGO3", "AGO4", "NCBP2", "ZC3H7B", "TUT4", "PUM2", "DICER1", "AGO1", "AGO2", "ZC3H7A", "DROSHA", "HNRNPA2B1", "IL6", "LIN28B", "HOXB-AS3", "SMAD1", "SMAD2", "SMAD3", "MECP2", "NCBP1", "SPOUT1", "SRRT", "DGCR8", "METTL3", "SRSF3", "BMP4", "STAT3", "TARBP2", "TGFB1", "TP53", "TUT7", "LIN28A", "SNIP1", "ZC3H10", "PRKRA", "RIPK1", "NUP155", "PUM1")
GOBP_RNA_STABILIZATION <- c("SYNCRIP", "PAIP1", "IGF2BP1", "IGF2BP3", "IGF2BP2","TRAF3IP2", "HNRNPA0", "TENT4A", "TIRAP", "CIRBP", "TENT5B", "MAPK14", "DAZ1", "DAZL", "DHX9", "RBM46", "TENT5D", "DHX36", "DKC1", "TRDMT1", "E2F1", "ELAVL1", "ELAVL4", "RBM24", "LARP4B", "LARP1", "TARDBP", "FUS", "NOCT", "GDNF", "PABPC1", "MEIOC", "HNRNPC", "HNRNPD", "HNRNPU", "ZAR1", "APOBEC1", "IREB2", "DND1", "METTL1", "MYD88", "YBX1", "PARN", "ZCCHC17", "PHAX", "RBM47", "TENT5C", "NSUN2", "NRDE2", "LARP1B", "TENT5A", "EIF4ENIF1", "DAZ3", "DAZ2", "DAZ4","METTL14", "TENT4B", "SLC11A1", "BOLL", "TRAF2", "TRAF5", "VIP", "FP36", "CSDE1", "METTL16", "TAF15", "RBM10", "AXIN2", "YBX3", "ANGEL2", "NAF1", "MAPKAPK2", "QKI", "IKBKE", "THRAP3")

gmt_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Databases/GOBP_REGULATORY_NCRNA_MEDIATED_GENE_SILENCING.v2024.1.Hs.gmt"

gmt_line <- readLines(gmt_path, n = 1)
gmt_fields <- strsplit(gmt_line, "\t")[[1]]

# 2. Extraer el nombre de la firma y los genes
GOBP_REGULATORY_NCRNA_MEDIATED_GENE_SILENCING <- gmt_fields[3:length(gmt_fields)]
signature_name <- gmt_fields[1] 



gene_sets <- list(GOBP_RNA_MODIFICATION = gobp_rna_mod, 
                  GOBP_MRNA_MODIFICATION = gobp_mrna_mod,
                  GOBP_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY = GOBP_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY, 
                  GOBP_POSITIVE_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY = GOBP_POSITIVE_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY,
                  GOCC_P_BODY = GOCC_P_BODY,
                  GOBP_MIRNA_PROCESSING = GOBP_MIRNA_PROCESSING,
                  GOBP_RNA_STABILIZATION = GOBP_RNA_STABILIZATION,
                  GOBP_REGULATORY_NCRNA_MEDIATED_GENE_SILENCING = GOBP_REGULATORY_NCRNA_MEDIATED_GENE_SILENCING
                  )
```


```{r}

merged_rna_clinical$TPM <- as.numeric(merged_rna_clinical$TPM)

# Convert TPM values into a matrix with genes as rows and samples as columns
tpm_df <- merged_rna_clinical %>%
  dplyr::select(Gene, Sample, TPM) %>%
  pivot_wider(
    names_from = Sample,
    values_from = TPM,
    values_fn = mean
  ) %>%
  column_to_rownames(var = "Gene")

tpm_matrix <- as.matrix(tpm_df)

# Define GSVA parameters
gsva.param <- gsvaParam(exprData = tpm_matrix, 
                        geneSets = gene_sets)

# Run GSVA
gsva_scores <- gsva(gsva.param, verbose = F)


```

Comprobar rango de GSVA_score y modificar pa que no se vea tan clarito

```{r}
summary(gsva_scores)
```


```{r}
# Escoge solo las firmas epitranscriptómicas
selected_pathways <- c("GOBP_RNA_MODIFICATION",
                  "GOBP_MRNA_MODIFICATION",
                  "GOBP_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY",
                  "GOBP_POSITIVE_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY",
                  "GOCC_P_BODY",
                  "GOBP_MIRNA_PROCESSING",
                  "GOBP_RNA_STABILIZATION",
                  "GOBP_REGULATORY_NCRNA_MEDIATED_GENE_SILENCING" )
heatmap_matrix <- gsva_scores[selected_pathways, ]

annotation_data <- merged_rna_clinical %>%
  dplyr::select(Sample, response_TAC1, sex, smoking_status) %>%
  distinct() %>%
  column_to_rownames("Sample")

# Asegúrate de que las muestras estén en el mismo orden que en el heatmap_matrix
annotation_data$smoking_status <- factor(annotation_data$smoking_status,
                                          levels = c("smoker", "former_smoker", "never_smoker", "Unknown"))
annotation_data <- annotation_data[colnames(heatmap_matrix), ]

# Define colores para las anotaciones
ann_colors <- list(
  response_TAC1 = c("responder" = "green", "non_responder" = "red", "Unknown" = "grey80"),
  sex = c("male" = "orchid1", "female" = "skyblue"),
  smoking_status = c("smoker" = "red", "former_smoker" = "orange", "never_smoker" = "blue", "Unknown" = "lightgrey")
)

# Crear objeto HeatmapAnnotation
top_annotation <- HeatmapAnnotation(
  df = annotation_data,
  col = ann_colors,
  annotation_legend_param = list(title_gp = gpar(fontsize = 10), labels_gp = gpar(fontsize = 8))
)

# -----------------------------------
# Crear Heatmap con ComplexHeatmap
# -----------------------------------

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Firm_heatmap.png", width = 4000, height = 3000, res = 300)

Heatmap(
  matrix = heatmap_matrix,
  name = "GSVA score",
  col = colorRamp2(c(-0.8, 0, 0.8), c("blue", "white", "red")),
  top_annotation = top_annotation,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 10),
  column_names_gp = gpar(fontsize = 8),
  column_title = "Epitranscriptomic Signatures (GSVA)",
  column_title_gp = gpar(fontsize = 14, fontface = "bold"),
  clustering_distance_rows = "euclidean",
  clustering_distance_columns = "euclidean"
)
dev.off()
```

Mismo código pero para pacientes WES. Creamos nueva gsva para ello: 


```{r}
# Leer variantes patogénicas
pathogenic <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/pathogenic_m6A_variants.tsv")

# Pacientes WES válidos
wes_patients <- unique(merged_rna_clinical$Tumor_Sample_Barcode)
wes_patients <- wes_patients[wes_patients != ""]

# Filtrar datos de expresión para solo esos pacientes
wes_rna_clinical <- merged_rna_clinical %>%
  filter(Tumor_Sample_Barcode %in% wes_patients)

# Crear columna de ID limpio desde Sample (quitando "RNA_FFPE_")
wes_rna_clinical <- wes_rna_clinical %>%
  mutate(Sample_clean = gsub("RNA_FFPE_", "", Sample))


# Crear matriz TPM para GSVA
tpm_df_wes <- wes_rna_clinical %>%
  dplyr::select(Gene, Sample, TPM) %>%
  pivot_wider(names_from = Sample, values_from = TPM, values_fn = mean) %>%
  column_to_rownames(var = "Gene")
tpm_matrix_wes <- as.matrix(tpm_df_wes)
tpm_matrix_wes[is.na(tpm_matrix_wes)] <- 0

# GSVA
gsva.param_wes <- gsvaParam(exprData = tpm_matrix_wes, geneSets = gene_sets)
gsva_scores_wes <- gsva(gsva.param_wes, verbose = FALSE)

# Subset epitranscriptomic signatures
selected_pathways <- c("GOBP_RNA_MODIFICATION",
                       "GOBP_MRNA_MODIFICATION",
                       "GOBP_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY",
                       "GOBP_POSITIVE_REGULATION_OF_CYTOPLASMIC_MRNA_PROCESSING_BODY_ASSEMBLY",
                       "GOCC_P_BODY",
                       "GOBP_MIRNA_PROCESSING",
                       "GOBP_RNA_STABILIZATION",
                       "GOBP_REGULATORY_NCRNA_MEDIATED_GENE_SILENCING")
heatmap_matrix_wes <- gsva_scores_wes[selected_pathways, ]

# Crear anotaciones clínicas usando Sample_clean
annotation_data_wes <- wes_rna_clinical %>%
  dplyr::select(Sample_clean, response_TAC1, sex, smoking_status) %>%
  distinct() %>%
  column_to_rownames("Sample_clean")


# Añadir columna de mutaciones patogénicas
# Convertir barcodes de mutaciones patogénicas a carácter si no lo son
patients_with_pathogenic <- unique(as.character(pathogenic$Tumor_Sample_Barcode))

# Anotar si hay mutaciones patogénicas
annotation_data_wes$pathogenic_mutation <- ifelse(rownames(annotation_data_wes) %in% patients_with_pathogenic, "Yes", "No")

# Definir niveles de factores
annotation_data_wes$smoking_status <- factor(annotation_data_wes$smoking_status,
                                             levels = c("smoker", "former_smoker", "never_smoker", "Unknown"))
annotation_data_wes$pathogenic_mutation <- factor(annotation_data_wes$pathogenic_mutation, levels = c("Yes", "No"))

# Alinear nombres con matriz TPM (quitando "RNA_FFPE_" para que coincidan)
colnames(heatmap_matrix_wes) <- gsub("RNA_FFPE_", "", colnames(heatmap_matrix_wes))
annotation_data_wes <- annotation_data_wes[colnames(heatmap_matrix_wes), ]

# Colores para anotaciones
ann_colors <- list(
  response_TAC1 = c("responder" = "green", "non_responder" = "red", "Unknown" = "grey80"),
  sex = c("male" = "orchid1", "female" = "skyblue"),
  smoking_status = c("smoker" = "red", "former_smoker" = "orange", "never_smoker" = "blue", "Unknown" = "lightgrey"),
  pathogenic_mutation = c("Yes" = "black", "No" = "white")
)

# Anotación superior del heatmap
top_annotation_wes <- HeatmapAnnotation(
  df = annotation_data_wes,
  col = ann_colors,
  annotation_legend_param = list(title_gp = gpar(fontsize = 10),
                                 labels_gp = gpar(fontsize = 8))
)


```

```{r}
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Firm_heatmap_wes.png", width = 4000, height = 3000, res = 300)

Heatmap(
  matrix = heatmap_matrix_wes,
  name = "GSVA score",
  col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
  top_annotation = top_annotation_wes,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 10),
  column_names_gp = gpar(fontsize = 8),
  clustering_distance_rows = "euclidean",  
  clustering_method_rows = "ward.D",
  column_title = "Epitranscriptomic Signatures (GSVA)",
  column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
dev.off()
```

Otros datos clinicos

```{r}
# Crear anotaciones clínicas usando Sample_clean
annotation_data_wes <- wes_rna_clinical %>%
  dplyr::select(Sample_clean, response_TAC1, sex, smoking_status, age, stage) %>%
  distinct() %>%
  column_to_rownames("Sample_clean")

# Añadir columna de mutaciones patogénicas
patients_with_pathogenic <- unique(as.character(pathogenic$Tumor_Sample_Barcode))
annotation_data_wes$pathogenic_mutation <- ifelse(rownames(annotation_data_wes) %in% patients_with_pathogenic, "Yes", "No")

# Convertir a factor y establecer niveles
annotation_data_wes$smoking_status <- factor(annotation_data_wes$smoking_status,
                                             levels = c("smoker", "former_smoker", "never_smoker", "Unknown"))
annotation_data_wes$pathogenic_mutation <- factor(annotation_data_wes$pathogenic_mutation, levels = c("Yes", "No"))

# Definir colores para anotaciones categóricas
ann_colors <- list(
  response_TAC1 = c("responder" = "green", "non_responder" = "red", "Unknown" = "grey80"),
  sex = c("male" = "orchid1", "female" = "skyblue"),
  smoking_status = c("smoker" = "red", "former_smoker" = "orange", "never_smoker" = "blue", "Unknown" = "lightgrey"),
  pathogenic_mutation = c("Yes" = "black", "No" = "white"),
  stage = c("I" = "lightgreen", "II" = "skyblue", "III" = "orange", "IV" = "indianred1", "Unknown" = "lightgrey") # Modifica según tus niveles reales
)

# Alinear nombres
colnames(heatmap_matrix_wes) <- gsub("RNA_FFPE_", "", colnames(heatmap_matrix_wes))
annotation_data_wes <- annotation_data_wes[colnames(heatmap_matrix_wes), ]

# Crear anotación del heatmap
top_annotation_wes <- HeatmapAnnotation(
  df = annotation_data_wes,
  col = ann_colors,
  annotation_legend_param = list(title_gp = gpar(fontsize = 10),
                                 labels_gp = gpar(fontsize = 8))
)


png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Firm_clinical2_wes.png", width = 4000, height = 3000, res = 300)

Heatmap(
  matrix = heatmap_matrix_wes,
  name = "GSVA score",
  col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
  top_annotation = top_annotation_wes,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 10),
  column_names_gp = gpar(fontsize = 8),
  clustering_distance_rows = "euclidean",  
  clustering_method_rows = "ward.D",
  column_title = "Epitranscriptomic Signatures (GSVA)",
  column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
dev.off()
```

```{r}


# 1. Leer las anotaciones de tipo Writer/Reader/Eraser
epitranscriptomic_genes <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/epitranscriptomic_regulators_annotated.txt")

# 2. Añadir categoría funcional a las variantes
pathogenic_annotated <- pathogenic %>%
  left_join(epitranscriptomic_genes, by = c("Hugo_Symbol" = "Gene_symbol"))

# 3. Crear tabla binaria: ¿cada paciente tiene mutación de tipo Writer, Reader, Eraser?
mutation_types_by_patient <- pathogenic_annotated %>%
  filter(!is.na(Function)) %>%
  mutate(Sample_clean = gsub("RNA_FFPE_", "", Tumor_Sample_Barcode)) %>%
  group_by(Sample_clean, Function) %>%
  summarise(has_mutation = TRUE, .groups = "drop") %>%
  pivot_wider(names_from = Function, values_from = has_mutation, values_fill = list(has_mutation = FALSE))


# 4. Asegurar que todas las muestras estén
all_samples <- colnames(heatmap_matrix_wes)
mutation_types_by_patient <- mutation_types_by_patient %>%
  complete(Sample_clean = all_samples, fill = list(Writer = FALSE, Reader = FALSE, Eraser = FALSE)) %>%
  column_to_rownames("Sample_clean")


mutation_types_by_patient[is.na(mutation_types_by_patient)] <- FALSE

# 5. Anotaciones clínicas
annotation_data_wes <- merged_rna_clinical %>%
  mutate(Sample_clean = gsub("RNA_FFPE_", "", Sample)) %>%
  filter(Tumor_Sample_Barcode %in% wes_patients) %>%
  dplyr::select(Sample_clean, response_TAC1, sex, smoking_status, stage) %>%
  distinct() %>%
  column_to_rownames("Sample_clean")

annotation_data_wes <- annotation_data_wes %>%
  mutate(smoking_status = as.character(smoking_status)) %>%
  mutate(smoking_status = ifelse(is.na(smoking_status) | smoking_status == "", "Unknown", smoking_status)) %>%
  mutate(smoking_status = factor(smoking_status, levels = c("smoker", "former_smoker", "never_smoker", "Unknown")))

annotation_data_wes <- annotation_data_wes %>%
  mutate(stage = ifelse(stage == "" | is.na(stage), "Unknown", stage)) 


# Añadir columna: ¿tiene mutación patogénica?
patients_with_pathogenic <- unique(pathogenic$Tumor_Sample_Barcode)
annotation_data_wes$pathogenic_mutation <- ifelse(rownames(annotation_data_wes) %in% patients_with_pathogenic, "Yes", "No")

# Reordenar para que coincida con el heatmap
annotation_data_wes <- annotation_data_wes[all_samples, ]

# Anotaciones tipo de mutación como `anno_simple`
mutation_annotations <- HeatmapAnnotation(
  writer = anno_simple(as.numeric(mutation_types_by_patient$Writer), col = c("0" = "white", "1" = "black")),
  reader = anno_simple(as.numeric(mutation_types_by_patient$Reader), col = c("0" = "white", "1" = "black")),
  eraser = anno_simple(as.numeric(mutation_types_by_patient$Eraser), col = c("0" = "white", "1" = "black")),
  which = "column",
  annotation_name_side = "right",
  annotation_legend_param = list(
    writer = list(title = "Writer", at = c("No", "Yes")),
    reader = list(title = "Reader", at = c("No", "Yes")),
    eraser = list(title = "Eraser", at = c("No", "Yes")),
    title_gp = gpar(fontsize = 10),
    labels_gp = gpar(fontsize = 8)
  )
)

# 🔹 Anotaciones clínicas como `df`
clinical_annotations <- HeatmapAnnotation(
  df = annotation_data_wes,
  col = list(
    response_TAC1 = c("responder" = "green", "non_responder" = "red", "Unknown" = "grey80"),
    sex = c("male" = "orchid1", "female" = "skyblue"),
    smoking_status = c("smoker" = "red", "former_smoker" = "orange", "never_smoker" = "blue", "Unknown" = "lightgrey"),
    pathogenic_mutation = c("Yes" = "black", "No" = "white"),
    stage = c("I" = "lightgreen", "II" = "skyblue", "III" = "orange", "IV" = "indianred1", "Unknown" = "lightgrey")
  ),
  which = "column",
  annotation_legend_param = list(title_gp = gpar(fontsize = 10), labels_gp = gpar(fontsize = 8))
)

# 🔹 Combinar ambas anotaciones
top_annotation_wes <- c(clinical_annotations, mutation_annotations)

# HEATMAP
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Firm_genetype_wes.png", width = 4000, height = 3000, res = 300)

Heatmap(
  matrix = heatmap_matrix_wes,
  name = "GSVA score",
  col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
  top_annotation = top_annotation_wes,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 10),
  column_names_gp = gpar(fontsize = 8),
  clustering_distance_rows = "euclidean",  
  clustering_method_rows = "ward.D",
  column_title = "Epitranscriptomic Signatures (GSVA)",
  column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
dev.off()
```


# Objective 2: To evaluate whether there is a dysregulation of the m6A machinery that could serve as a biomarker of response to immunotherapy in RCC patients.


## 1.	To identify somatic variants from the m6A machinery that are exclusively found in responder and non-responder patients


### 1.1. Identify genes that are exclusively mutated in responders and non-responders to immunotherapy 

Ir a chunk 15 para descargar los datos en el entorno.

```{r}
# Separar datos en respondedores y no respondedores

responders <- clinical_data %>% filter(response_TAC1 == "responder") %>% pull(Tumor_Sample_Barcode)
non_responders <- clinical_data %>% filter(response_TAC1 == "non_responder") %>% pull(Tumor_Sample_Barcode)

# Opción 2: Usando summarise directamente

# Respondedores
resp_mutated_genes <- m6A_maf@data %>%
  filter(Tumor_Sample_Barcode %in% responders) %>%
  group_by(Hugo_Symbol, Tumor_Sample_Barcode) %>%
  summarise(nbVariants = n(), .groups = "drop")

nbSamples_gene_resp <- resp_mutated_genes %>%
  group_by(Hugo_Symbol) %>%
  summarise(n_samples = n(), .groups = "drop")

nbVariants_gene_resp <- resp_mutated_genes %>%
  group_by(Hugo_Symbol) %>%
  summarise(nbVariants = sum(nbVariants), .groups = "drop")


# No respondedores
nonResp_mutated_genes <- m6A_maf@data %>%
  filter(Tumor_Sample_Barcode %in% non_responders) %>%
  group_by(Hugo_Symbol, Tumor_Sample_Barcode) %>%
  summarise(nbVariants = n(), .groups = "drop")

nbSamples_gene_nonResp <- nonResp_mutated_genes %>%
  group_by(Hugo_Symbol) %>%
  summarise(n_samples = n(), .groups = "drop")

nbVariants_gene_nonResp <- nonResp_mutated_genes %>%
  group_by(Hugo_Symbol) %>%
  summarise(nbVariants = sum(nbVariants), .groups = "drop")


write.table(resp_mutated_genes, 'Results/allMutatedGenes_responders.tsv', col.names = T, row.names = F, quote=F, sep='\t')

write.table(nonResp_mutated_genes, 'Results/allMutatedGenes_non_responders.tsv', col.names = T, row.names = F, quote=F, sep='\t')

# Genes con múltiples mutaciones por paciente. Esto esta copiado de jenny pero no quiero hacerlo 
pmultipleResp <- resp_mutated_genes[resp_mutated_genes$nbVariants >= 1, ]
pmultipleNonResp <- nonResp_mutated_genes[nonResp_mutated_genes$nbVariants >= 1, ]

# Genes mutados múltiples veces solo en respondedores
pjustResp <- pmultipleResp[!(pmultipleResp$Hugo_Symbol %in% pmultipleNonResp$Hugo_Symbol), ]

# Versión estricta: excluye todos los genes que aparecen en los no respondedores
pjustResp_strict <- pmultipleResp[!(pmultipleResp$Hugo_Symbol %in% nonResp_mutated_genes$Hugo_Symbol), ]

# Genes mutados múltiples veces solo en no respondedores
pjustNonResp <- pmultipleNonResp[!(pmultipleNonResp$Hugo_Symbol %in% pmultipleResp$Hugo_Symbol), ]

# Versión estricta: excluye todos los genes que aparecen en los respondedores
pjustNonResp_strict <- pmultipleNonResp[!(pmultipleNonResp$Hugo_Symbol %in% resp_mutated_genes$Hugo_Symbol), ]

write.table(pjustResp_strict,
            file = "results/pjustResp_strict.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# Guardar genes con múltiples mutaciones solo en no respondedores (estricto)
write.table(pjustNonResp_strict,
            file = "results/pjustNonResp_strict.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

```


### 1.2. Identify specific variants that are exclusively present in responders and non-responders to immunotherapy 

```{r}
# Separar datos en respondedores y no respondedores

responders <- clinical_data %>% filter(response_TAC1 == "responder") %>% pull(Tumor_Sample_Barcode)
non_responders <- clinical_data %>% filter(response_TAC1 == "non_responder") %>% pull(Tumor_Sample_Barcode)

# Opción 2: Usando summarise directamente

# Respondedores
resp_mutated_genes <- m6A_maf@data %>%
  filter(Tumor_Sample_Barcode %in% responders) %>%
  group_by( shortVariantID, Tumor_Sample_Barcode) %>%
  summarise(nbVariants = n(), .groups = "drop")

nbSamples_gene_resp <- resp_mutated_genes %>%
  group_by( shortVariantID) %>%
  summarise(n_samples = n(), .groups = "drop")

nbVariants_gene_resp <- resp_mutated_genes %>%
  group_by( shortVariantID) %>%
  summarise(nbVariants = sum(nbVariants), .groups = "drop")


# No respondedores
nonResp_mutated_genes <- m6A_maf@data %>%
  filter(Tumor_Sample_Barcode %in% non_responders) %>%
  group_by( shortVariantID, Tumor_Sample_Barcode) %>%
  summarise(nbVariants = n(), .groups = "drop")

nbSamples_gene_nonResp <- nonResp_mutated_genes %>%
  group_by( shortVariantID) %>%
  summarise(n_samples = n(), .groups = "drop")

nbVariants_gene_nonResp <- nonResp_mutated_genes %>%
  group_by( shortVariantID) %>%
  summarise(nbVariants = sum(nbVariants), .groups = "drop")


write.table(resp_mutated_genes, 'Results/all_variants_responders.tsv', col.names = T, row.names = F, quote=F, sep='\t')

write.table(nonResp_mutated_genes, 'Results/all_variants_responders.tsv', col.names = T, row.names = F, quote=F, sep='\t')

# Genes con múltiples mutaciones por paciente. Esto esta copiado de jenny pero no quiero hacerlo 
pmultipleResp <- resp_mutated_genes[resp_mutated_genes$nbVariants >= 1, ]
pmultipleNonResp <- nonResp_mutated_genes[nonResp_mutated_genes$nbVariants >= 1, ]

# Genes mutados múltiples veces solo en respondedores
pjustResp <- pmultipleResp[!(pmultipleResp$ shortVariantID %in% pmultipleNonResp$ shortVariantID), ]

# Versión estricta: excluye todos los genes que aparecen en los no respondedores
pjustResp_strict <- pmultipleResp[!(pmultipleResp$ shortVariantID %in% nonResp_mutated_genes$ shortVariantID), ]

# Genes mutados múltiples veces solo en no respondedores
pjustNonResp <- pmultipleNonResp[!(pmultipleNonResp$ shortVariantID %in% pmultipleResp$ shortVariantID), ]

# Versión estricta: excluye todos los genes que aparecen en los respondedores
pjustNonResp_strict <- pmultipleNonResp[!(pmultipleNonResp$ shortVariantID %in% resp_mutated_genes$ shortVariantID), ]

write.table(pjustResp_strict,
            file = "results/pjustResp_variant.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# Guardar genes con múltiples mutaciones solo en no respondedores (estricto)
write.table(pjustNonResp_strict,
            file = "results/pjustNonResp_variant.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

```

## 2. To identify differentially expressed genes from the m6A machinery associated with immunotherapy response

### 2.1. Differential expression analysis between responder and non-responder patients 

Cargar datos de RNA en chunk 18 y descargar clinical data.
3

```{r}
# ---------------------------------------------
# 1. Load count matrix and metadata
# ---------------------------------------------
rna_expression_all <- rna_expression_all %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", Sample),
         Sample = gsub("\\.tsv$", "", Sample))        

count_matrix <- rna_expression_all %>%
  dplyr::select(Gene, Sample, Expression) %>%
  group_by(Gene, Sample) %>%
  summarise(Expression = sum(Expression), .groups = "drop") %>%  # Handles duplicates if any
  pivot_wider(names_from = Sample, values_from = Expression) %>%
  column_to_rownames("Gene")  # Gene names as rownames

count_matrix <- as.matrix(count_matrix)


# Filter metadata for WES patients and known response status
metadata <- clinical_data %>%
  filter(response_TAC1 %in% c("responder", "non_responder")) %>%
  distinct(sample_ID, response_TAC1) %>%
  column_to_rownames("sample_ID")

# Match samples in both datasets
common_samples <- intersect(colnames(count_matrix), rownames(metadata))
count_matrix_filtered <- count_matrix[, common_samples]
metadata <- metadata[common_samples, , drop = FALSE]

# ---------------------------------------------
# 2. Create DESeq2 object
# ---------------------------------------------
dds <- DESeqDataSetFromMatrix(countData = count_matrix_filtered,
                              colData = metadata,
                              design = ~ response_TAC1)


# ---------------------------------------------
# 3. Run DESeq2
# ---------------------------------------------
dds <- DESeq(dds)

# ---------------------------------------------
# 4. Extract results
# ---------------------------------------------
res <- results(dds, contrast = c("response_TAC1", "responder", "non_responder"))
res_df <- as.data.frame(res) %>%
  rownames_to_column("Gene") %>%
  arrange(padj)

# ---------------------------------------------
# 5. Filter m6A genes only
# ---------------------------------------------
epitranscriptomic_genes <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/epitranscriptomic_regulators_annotated.txt", 
                                 sep = "\t", header = TRUE)

m6A_genes <- epitranscriptomic_genes %>%
  filter(Mark == "m6A") %>%
  pull(Gene_symbol)

m6a_gene_list <- unique(m6A_genes)

res_m6a <- res_df %>%
  filter(Gene %in% m6a_gene_list)

# ---------------------------------------------
# 6. Save results
# ---------------------------------------------
write.table(res_m6a,
            file = "Results/DEG_m6A_responder_vs_nonresponder.tsv",
            sep = "\t", quote = FALSE, row.names = FALSE)

```

```{r}
# ---------------------------------------------
# 7. Boxplot of most significant gene
# ---------------------------------------------

# Extraer el top 1 gen más significativo
top_gene <- res_m6a %>% filter(!is.na(padj)) %>% dplyr::slice(1) %>% pull(Gene)

# Obtener expresión normalizada (transformación rlog para visualización más clara)
rld <- rlog(dds, blind = TRUE)
rlog_mat <- assay(rld)

# Crear dataframe para ggplot
plot_data <- data.frame(
  Expression = rlog_mat[top_gene, common_samples],
  Sample = common_samples,
  response_TAC1 = metadata$`response_TAC1`
)

# Añadir el p-valor ajustado
padj_val <- signif(res_m6a$padj[res_m6a$Gene == top_gene], 3)

# Graficar
ggplot(plot_data, aes(x = response_TAC1, y = Expression, fill = response_TAC1)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.1, size = 1.5) +
  labs(title = paste0("Top DE m6A Gene: ", top_gene),
       subtitle = paste0("Adjusted p-value: ", padj_val),
       x = "Response Group",
       y = "Normalized Expression (rlog)") +
  scale_fill_manual(values = c("responder" = "skyblue", "non_responder" = "indianred1")) +
  theme_minimal(base_size = 14)

```



```{r}
# Obtener expresión normalizada con rlog
rld <- rlog(dds, blind = TRUE)
rlog_mat <- assay(rld)

# Loop para generar los boxplots
for (gene in res_m6a$Gene) {
  
  # Verifica que el gen existe en rlog_mat
  if (!(gene %in% rownames(rlog_mat))) next
  
  # Crear dataframe para graficar
  plot_data <- data.frame(
    Expression = rlog_mat[gene, common_samples],
    Sample = common_samples,
    response_TAC1 = metadata$`response_TAC1`
  )
  
  # Obtener p-valor ajustado
  padj_val <- signif(res_m6a$padj[res_m6a$Gene == gene], 3)
  
  # Crear y mostrar el boxplot
  print(
    ggplot(plot_data, aes(x = response_TAC1, y = Expression, fill = response_TAC1)) +
      geom_boxplot(outlier.shape = NA, alpha = 0.7) +
      geom_jitter(width = 0.1, size = 1.5) +
      labs(title = paste0(gene),
           subtitle = paste0("Adjusted p-value: ", padj_val),
           x = "Response Group",
           y = "Normalized Expression (rlog)") +
      scale_fill_manual(values = c("responder" = "skyblue", "non_responder" = "indianred1")) +
      theme_minimal(base_size = 14)
  )
}
```


```{r}
library(patchwork)

plots <- list()

for (gene in res_m6a$Gene) {
  
  if (!(gene %in% rownames(rlog_mat))) next
  
  plot_data <- data.frame(
    Expression = rlog_mat[gene, common_samples],
    Sample = common_samples,
    response_TAC1 = metadata$`response_TAC1`
  )
  
  padj_val <- signif(res_m6a$pvalue[res_m6a$Gene == gene], 3)
  
  p <- ggplot(plot_data, aes(x = response_TAC1, y = Expression, fill = response_TAC1)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.7) +
    geom_jitter(width = 0.1, size = 1.5) +
    labs(title = paste0(gene),
         subtitle = paste0("Adjusted p-value: ", padj_val),
         x = "Response Group",
         y = "Normalized Expression (rlog)") +
    scale_fill_manual(values = c("responder" = "skyblue", "non_responder" = "indianred1")) +
    theme_minimal(base_size = 10)
  
  plots[[gene]] <- p
}

# Combinar y guardar (8 columnas, ajustable)
combined_plot <- wrap_plots(plots, ncol = 4)

ggsave("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/all_boxplots_combined.png", combined_plot, width = 20, height = 24, dpi = 300)

```

### 2.2. Gene set enrichment analysis to identify epitranscriptomic-related pathways associated to immunotherapy response


```{r}
# ---------------------------------------------
# 1. Load required packages
# ---------------------------------------------
library(DESeq2)
library(clusterProfiler)
library(msigdbr)
library(tidyverse)

# 1. Prepare ranked gene list (for GSEA)
# ---------------------------------------------
# Supongo que ya tienes un objeto 'res' de DESeq2 con los resultados
# Asegúrate de que 'res' esté definido, si no, define 'res' antes de usarlo
# Ejemplo:
# res <- results(dds)  # dds es el objeto DESeqDataSet

res_gsea <- as.data.frame(res) %>%
  rownames_to_column("gene") %>%
  filter(!is.na(log2FoldChange)) %>%
  arrange(desc(log2FoldChange))

# Crear la lista de genes clasificados
gene_list <- res_gsea$log2FoldChange
names(gene_list) <- res_gsea$gene

# Asegurarse de que no haya valores NAs o vacíos en los nombres de los genes
gene_list <- gene_list[!is.na(names(gene_list)) & names(gene_list) != ""]

# 2. Load GO gene sets (MSigDB C5)
# ---------------------------------------------
msigdb_sets <- msigdbr(species = "Homo sapiens", collection = "C5")  # GO terms
gsea_sets <- msigdb_sets %>% dplyr::select(gs_name, gene_symbol)

# 3. Run GSEA
# ---------------------------------------------
gsea_results <- GSEA(
  geneList = gene_list,
  TERM2GENE = gsea_sets,
  pvalueCutoff = 0.05,
  verbose = TRUE
)  

write.csv(as.data.frame(gsea_results), file = "gsea_results.csv", row.names = FALSE)

```


```{r}
# Load necessary libraries
library(clusterProfiler)
library(ggplot2)
library(readr)
library(dplyr)

# Step 1: Load the filtered GSEA results
gsea_epi <- read_csv("gsea_results.csv")


# Step 2: Filter to get top 20 routes based on NES (Normalized Enrichment Score)
gsea_top20 <- gsea_epi %>%
  arrange(desc(NES)) %>%  # Ordenamos de mayor a menor por NES
  head(20)  # Tomamos las primeras 20 filas

# Step 3: Create a dotplot where point size represents the number of genes
png("Results/GSEA_epitranscriptomic_dotplot.png", width = 1200, height = 800, res = 150)

ggplot(gsea_top20, aes(x = NES, y = Description)) +
  geom_point(aes(size = setSize, color = p.adjust)) +  # Size now reflects number of genes
  scale_color_gradient(low = "red", high = "blue", name = "Adjusted p-value") +
  scale_size_continuous(name = "Gene Count") +  # New legend title
  labs(title = "Top 20 GSEA - Epitranscriptomic Pathways",
       x = "Normalized Enrichment Score (NES)",
       y = "") +
  theme_minimal()

dev.off()

```

### 2.3. Compare gene expression profiles of the m6A machinery between responders and non-responders 

	
## 3. To construct machine learning models and Kaplan-Meier estimators, based on the mutational and expression profiles, to predict immunotherapy response and survival

### 3.1. Kaplan-Meier and Cox Hazards ratio analysis to assess the effect of m6A machinery mutational status and expression levels on patient survival 

Primero se ha representado KM sobre pacientes NR y  R calculando su OS. Para ello se ha utilizado la fecha de last contact o la fecha de exitus como fecha fin y la fecha de inicio de ICI par la start. El momento clave (0, 1) es si hay muerte o no.

```{r}
# Datos clínicos con columnas: sample_ID, OS_time, OS_status
# Import Clinical Data & Remove Last 9 Rows
clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized.txt"
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)

# Expresión rlog de DESeq2: código 2.1 de expresión diferencial

# Lista de genes m6A: m6a_genes$Gene_symbol
epitranscriptomic_genes <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/epitranscriptomic_regulators_annotated.txt", 
                                 sep = "\t", header = TRUE)
m6a_genes <- epitranscriptomic_genes %>%
  filter(Mark == "m6A") %>%
  pull(Gene_symbol)


# Modificar el bloque para crear 'os_end_time' y calcular 'OS_time_months'
# Crear la columna 'new_date_existus' basada en 'date_existus'
clinical_data$new_date_existus <- clinical_data$date_exitus

# Bucle para recorrer cada fila y sustituir valores vacíos en 'new_date_existus'
for (i in 1:nrow(clinical_data)) {
  if (clinical_data$new_date_existus[i] == "") {
    clinical_data$new_date_existus[i] <- clinical_data$date_last_contact[i]
  }
}

# Convertir las columnas 'date_existus', 'date_last_contact', y 'ICI_start' a formato Date
clinical_data$new_date_existus <- as.Date(clinical_data$new_date_existus, format="%d/%m/%Y")
clinical_data$ICI_start <- as.Date(clinical_data$ICI_start, format="%d/%m/%Y")

# Crear la columna 'ostime_month' con la diferencia en años entre 'ICI_start' y 'date_existus'
# Primero, calculamos la diferencia en meses y luego la convertimos a años
clinical_data$OS_time_months <- as.numeric(difftime(clinical_data$new_date_existus, clinical_data$ICI_start, units = "days")) / 365.25

clinical_data$OS_status <- clinical_data$exitus


# Limpiar nombres de muestra y filtrar por datos disponibles de supervivencia
surv_data <- clinical_data %>%
  filter(!is.na(OS_time_months) & !is.na(OS_status)) %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample)) %>%
  distinct(Sample, OS_time_months, OS_status)

# Intersección entre expresión y datos clínicos
common_samples_surv <- intersect(colnames(rlog_mat), surv_data$Sample)
rlog_sub <- rlog_mat[, common_samples_surv]
surv_data <- surv_data %>% filter(Sample %in% common_samples_surv)

# Filtrar datos para responder/non responder
surv_response_data <- clinical_data %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample)) %>%
  filter(response_TAC1 %in% c("responder", "non_responder"),
         !is.na(OS_time_months), !is.na(OS_status)) %>%
  distinct(Sample, response_TAC1, OS_time_months, OS_status)

# Objeto de supervivencia
surv_obj <- Surv(time = surv_response_data$OS_time_months, event = surv_response_data$OS_status)

# Ajustar modelo Kaplan-Meier
fit_km_response <- survfit(surv_obj ~ response_TAC1, data = surv_response_data)

# Graficar KM con eje de tiempo en meses
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_OS.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_response,
  data = surv_response_data,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
    pval.size = 3,
  legend.title = "Response",
  legend.labs = c("Non Responder", "Responder"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
    risk.table.height = 0.3,  # Ajustar la altura de la tabla de riesgo (valor entre 0 y 1)
  risk.table.fontsize = 3,  # Reducir el tamaño de la fuente en la tabla
  risk.table.y.text.col = TRUE,  # Colorear las filas de la tabla de riesgo
  risk.table.y.text.size = 2,  # Tamaño de texto de las etiquetas en la tabla
  xlab = "Time (Years)",  # Cambiar etiqueta del eje X a meses
  break.time.by = 1  # Ajustar la frecuencia de los ticks en el eje X
)
dev.off()

```

Ahora separamos segun si tienen mutaciones en el m6A con efecto en proteina o no:

Para ello cargamos un documento creado con estos datos

```{r}
surv_response_data_pe <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM.txt", header = TRUE, sep = "\t")
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "unknown")
# Convertir y manejar los valores no numéricos

# Reemplazar las comas por puntos en la columna OS_time_months
surv_response_data_pe$OS_time_months <- gsub(",", ".", surv_response_data_pe$OS_time_months)

# Convertir la columna a numérica (después de reemplazar las comas)
surv_response_data_pe$OS_time_months <- as.numeric(surv_response_data_pe$OS_time_months)

# Filtrar los datos con Mutational_Status diferente de "Unknown" (repetido)
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "Unknown")

# Intersección entre expresión y datos clínicos
common_samples_surv <- intersect(colnames(rlog_mat), surv_data$Sample)
rlog_sub <- rlog_mat[, common_samples_surv]
surv_data <- surv_data %>% filter(Sample %in% common_samples_surv)

# Objeto de supervivencia
surv_obj <- Surv(time = surv_response_data_pe$OS_time_months, event = surv_response_data_pe$OS_status)

# Ajustar modelo Kaplan-Meier
fit_km_response <- survfit(surv_obj ~ Mutational_Status, data = surv_response_data_pe)

# Graficar KM con eje de tiempo en meses
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_OS_MS.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_response,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Mutational Status",
  legend.labs = c("Protein Effect", "Non Protein Effect"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,  
  risk.table.fontsize = 3, 
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,  
  xlab = "Time (Years)",  
  break.time.by = 1  
)
dev.off()

```
Ahora distinguimos en reader writter y eraser 

```{r}
# Leer el archivo
surv_response_data_pe <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM.txt", header = TRUE, sep = "\t")

# Filtrar los datos con Mutational_Status diferente de "unknown"
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "unknown")

# Reemplazar las comas por puntos en la columna OS_time_months
surv_response_data_pe$OS_time_months <- gsub(",", ".", surv_response_data_pe$OS_time_months)

# Convertir la columna a numérica (después de reemplazar las comas)
surv_response_data_pe$OS_time_months <- as.numeric(surv_response_data_pe$OS_time_months)

# Filtrar los datos con Mutational_Status diferente de "Unknown" (repetido)
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "Unknown")

# Convertir las columnas eraser, writer, reader a variables binarias (0 y 1)
surv_response_data_pe <- surv_response_data_pe %>%
  mutate(
    eraser = ifelse(Eraser == "Eraser", 1, 0),
    writer = ifelse(Writter == "Writter", 1, 0),
    reader = ifelse(Reader == "Reader", 1, 0)
  )

# Intersección entre expresión y datos clínicos
common_samples_surv <- intersect(colnames(rlog_mat), surv_data$Sample)
rlog_sub <- rlog_mat[, common_samples_surv]
surv_data <- surv_data %>% filter(Sample %in% common_samples_surv)

# Graficar para cada grupo (eraser, writer, reader)

# 1. Para eraser (Mutación de tipo eraser)
surv_obj_eraser <- Surv(time = surv_response_data_pe$OS_time_months, event = surv_response_data_pe$OS_status)
fit_km_eraser <- survfit(surv_obj_eraser ~ eraser, data = surv_response_data_pe)

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_OS_Eraser.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_eraser,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Eraser Mutation",
  legend.labs = c("No Eraser", "Eraser"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,
  risk.table.fontsize = 3,
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,
  xlab = "Time (Years)",
  break.time.by = 1
)
dev.off()

# 2. Para writer (Mutación de tipo writer)
surv_obj_writer <- Surv(time = surv_response_data_pe$OS_time_months, event = surv_response_data_pe$OS_status)
fit_km_writer <- survfit(surv_obj_writer ~ writer, data = surv_response_data_pe)

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_OS_Writer.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_writer,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Writer Mutation",
  legend.labs = c("No Writer", "Writer"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,
  risk.table.fontsize = 3,
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,
  xlab = "Time (Years)",
  break.time.by = 1
)
dev.off()

# 3. Para reader (Mutación de tipo reader)
surv_obj_reader <- Surv(time = surv_response_data_pe$OS_time_months, event = surv_response_data_pe$OS_status)
fit_km_reader <- survfit(surv_obj_reader ~ reader, data = surv_response_data_pe)

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_OS_Reader.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_reader,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Reader Mutation",
  legend.labs = c("No Reader", "Reader"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,
  risk.table.fontsize = 3,
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,
  xlab = "Time (Years)",
  break.time.by = 1
)
dev.off()
```
Repetimos pero con PFS

A continuación se ha representado KM sobre pacientes NR y  R calculando su PFS. Para ello se ha utilizado la fecha de last contact o la fecha de exitus como fecha fin y la fecha de inicio de ICI par la start. El momento clave (0, 1) es si hay muerte o no.

```{r}
# Cargar los datos clínicos (en formato Excel)

clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized_2.xlsx"
clinical_data <- read_excel(clinical_data_path)

# Crear la columna 'new_date_existus' basada en 'date_last_contact' o 'ICI_end' dependiendo de 'ICI_progression'
clinical_data <- clinical_data %>%
  mutate(new_date_existus = if_else(ICI_progression == 1, ICI_end, date_last_contact))

# Crear la columna 'PFS_time_months' (diferencia en meses entre ICI_start y new_date_existus)
clinical_data$PFS_time_months <- as.numeric(difftime(clinical_data$new_date_existus, clinical_data$ICI_start, units = "days")) / 365.25

# Establecer el estado de progresión: 1 si progresión, 0 si no progresión
clinical_data$PFS_status <- clinical_data$ICI_progression

# Filtrar las muestras que tienen datos completos de PFS
surv_data_pfs <- clinical_data %>%
  filter(!is.na(PFS_time_months) & !is.na(PFS_status)) %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample)) %>%
  distinct(Sample, PFS_time_months, PFS_status)

surv_data_pfs$response_TAC1 <- clinical_data$response_TAC1
# Intersección entre expresión y datos clínicos (como antes, rlog_mat debe estar disponible)
#common_samples_surv_pfs <- intersect(colnames(rlog_mat), surv_data_pfs$Sample)
#rlog_sub_pfs <- rlog_mat[, common_samples_surv_pfs]
#surv_data_pfs <- surv_data_pfs %>% filter(Sample %in% common_samples_surv_pfs)

# Objeto de supervivencia para PFS
surv_obj_pfs <- Surv(time = surv_data_pfs$PFS_time_months, event = surv_data_pfs$PFS_status)

# Ajustar modelo Kaplan-Meier para PFS
fit_km_response_pfs <- survfit(surv_obj_pfs ~ response_TAC1, data = surv_data_pfs)

# Graficar Kaplan-Meier para PFS con eje de tiempo en meses
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_PFS.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_response_pfs,
  data = surv_data_pfs,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Response",
  legend.labs = c("Non Responder", "Responder"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,  # Ajustar la altura de la tabla de riesgo (valor entre 0 y 1)
  risk.table.fontsize = 3,  # Reducir el tamaño de la fuente en la tabla
  risk.table.y.text.col = TRUE,  # Colorear las filas de la tabla de riesgo
  risk.table.y.text.size = 2,  # Tamaño de texto de las etiquetas en la tabla
  xlab = "Time (Years)",  # Cambiar etiqueta del eje X a meses
  break.time.by = 1  # Ajustar la frecuencia de los ticks en el eje X
)
dev.off()


```
```{r}
# Leer el archivo de PFS
surv_response_data_pe <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM_PFS.txt", header = TRUE, sep = "\t")

# Filtrar los datos con Mutational_Status conocido
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "unknown" & Mutational_Status != "Unknown")

# Reemplazar comas por puntos y convertir a numérico
surv_response_data_pe$PFS_time_months <- gsub(",", ".", surv_response_data_pe$PFS_time_months)
surv_response_data_pe$PFS_time_months <- as.numeric(surv_response_data_pe$PFS_time_months)

# Filtrar los datos con Mutational_Status diferente de "Unknown" (repetido)
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "Unknown")

# Objeto de supervivencia
surv_obj <- Surv(time = surv_response_data_pe$PFS_time_months, event = surv_response_data_pe$PFS_status)

# Ajustar modelo Kaplan-Meier
fit_km_response <- survfit(surv_obj ~ Mutational_Status, data = surv_response_data_pe)

# Graficar KM con eje de tiempo en meses
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_PFS_MS.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_response,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Mutational Status",
  legend.labs = c("Protein Effect", "Non Protein Effect"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,  
  risk.table.fontsize = 3, 
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,  
  xlab = "Time (Years)",  
  break.time.by = 1  
)
dev.off()
```




```{r}


# Leer el archivo de PFS
surv_response_data_pe <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM_PFS.txt", header = TRUE, sep = "\t")

# Filtrar los datos con Mutational_Status conocido
surv_response_data_pe <- surv_response_data_pe %>% filter(Mutational_Status != "unknown" & Mutational_Status != "Unknown")

# Reemplazar comas por puntos y convertir a numérico
surv_response_data_pe$PFS_time_months <- gsub(",", ".", surv_response_data_pe$PFS_time_months)
surv_response_data_pe$PFS_time_months <- as.numeric(surv_response_data_pe$PFS_time_months)

# Convertir columnas a binarias
surv_response_data_pe <- surv_response_data_pe %>%
  mutate(
    eraser = ifelse(Eraser == "Eraser", 1, 0),
    writer = ifelse(Writter == "Writter", 1, 0),
    reader = ifelse(Reader == "Reader", 1, 0)
  )

# Crear objeto de supervivencia
surv_obj <- Surv(time = surv_response_data_pe$PFS_time_months, event = surv_response_data_pe$PFS_status)

# -----------------------------
# Gráfico 1: Eraser
fit_km_eraser <- survfit(surv_obj ~ eraser, data = surv_response_data_pe)

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_PFS_Eraser.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_eraser,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Eraser Mutation",
  legend.labs = c("No Eraser", "Eraser"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,
  risk.table.fontsize = 3,
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,
  xlab = "Time (Years)",
  break.time.by = 1
)
dev.off()

# -----------------------------
# Gráfico 2: Writer
fit_km_writer <- survfit(surv_obj ~ writer, data = surv_response_data_pe)

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_PFS_Writer.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_writer,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Writer Mutation",
  legend.labs = c("No Writer", "Writer"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,
  risk.table.fontsize = 3,
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,
  xlab = "Time (Years)",
  break.time.by = 1
)
dev.off()

# -----------------------------
# Gráfico 3: Reader
fit_km_reader <- survfit(surv_obj ~ reader, data = surv_response_data_pe)

png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/KM_PFS_Reader.png", width = 1000, height = 1000, res = 300)
ggsurvplot(
  fit_km_reader,
  data = surv_response_data_pe,
  pval = TRUE,
  risk.table = TRUE,
  conf.int = FALSE,
  pval.size = 3,
  legend.title = "Reader Mutation",
  legend.labs = c("No Reader", "Reader"),
  palette = c("indianred1", "skyblue"),
  ggtheme = theme_minimal(base_size = 10),
  risk.table.height = 0.3,
  risk.table.fontsize = 3,
  risk.table.y.text.col = TRUE,
  risk.table.y.text.size = 2,
  xlab = "Time (Years)",
  break.time.by = 1
)
dev.off()


```


Cox-Hazard 

Análisis de Cox Hazard para supervivencia global (OS) según tipo de mutación


COX HAZARD

```{r}
# ────────────────────────────────────────────────
# 1. Cargar datos
# ────────────────────────────────────────────────

# Leer datos clínicos y de supervivencia
clinical_data <- clinical_data %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample))

surv_response_data_pe <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM.txt",
                                    header = TRUE, sep = "\t")

surv_response_data_pe <- surv_response_data_pe %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", Sample),
         Sample = gsub("\\.tsv$", "", Sample))

# ────────────────────────────────────────────────
# 2. Unir datos clínicos con datos de OS
# ────────────────────────────────────────────────
merged_os <- surv_response_data_pe %>%
  left_join(clinical_data %>%
              dplyr::select(Sample, sex, response_TAC1, age),
            by = "Sample") %>%
  filter(!is.na(OS_time_months), !is.na(OS_status))

# Reemplazar comas por puntos y convertir tiempo a numérico
merged_os$OS_time_months <- as.numeric(gsub(",", ".", merged_os$OS_time_months))

# Clasificar y renombrar grupos de edad
merged_os <- merged_os %>%
  mutate(
    response_TAC1 = factor(response_TAC1, levels = c("non_responder", "responder")),
    sex = factor(sex),
    age_group = ifelse(age <= median(age, na.rm = TRUE), "young", "old"),
    age_group = factor(age_group, levels = c("young", "old"))
  )

# Renombrar niveles para claridad en el gráfico
levels(merged_os$age_group) <- c("young (≤63)", "old (>63)")

# ────────────────────────────────────────────────
# 3. Modelo de Cox multivariado (OS)
# ────────────────────────────────────────────────
library(survival)

surv_obj <- Surv(time = merged_os$OS_time_months, event = merged_os$OS_status)

cox_model <- coxph(surv_obj ~ response_TAC1 + sex + age_group, data = merged_os)

# ────────────────────────────────────────────────
# 4. Forest Plot
# ────────────────────────────────────────────────
library(survminer)

ggforest(cox_model,
         data = merged_os,
         main = "Cox Model for Overall Survival",
         fontsize = 1.0,
         cpositions = c(0.02, 0.22, 0.4),
         refLabel = "Reference",
         noDigits = 2)

# Guardar la figura
ggsave("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Forest_Cox_OS_Response_Sex_Age.png",
       width = 10, height = 8, dpi = 300)


```

```{r}

# ────────────────────────────────────────────────
# 1. Cargar librerías necesarias
# ────────────────────────────────────────────────
library(dplyr)
library(survival)
library(survminer)
library(ggplot2)

# ────────────────────────────────────────────────
# 2. Cargar y limpiar datos para PFS
# ────────────────────────────────────────────────
# Leer el dataset
surv_response_data_pfs <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM_PFS.txt", 
                                     header = TRUE, sep = "\t")

# Limpiar columnas
surv_response_data_pfs <- surv_response_data_pfs %>%
  mutate(
    Sample = gsub("^htseq-RNA_FFPE_", "", Sample),
    Sample = gsub("\\.tsv$", "", Sample),
    PFS_time_months = as.numeric(gsub(",", ".", PFS_time_months))
  )

# ────────────────────────────────────────────────
# 3. Unir con datos clínicos y preparar variables
# ────────────────────────────────────────────────
merged_pfs <- surv_response_data_pfs %>%
  left_join(clinical_data %>%
              dplyr::select(Sample, sex, response_TAC1, age),
            by = "Sample") %>%
  filter(!is.na(PFS_time_months), !is.na(PFS_status)) %>%
  mutate(
    response_TAC1 = factor(response_TAC1, levels = c("non_responder", "responder")),
    sex = factor(sex),
    age_group = ifelse(age <= median(age, na.rm = TRUE), "young", "old"),
    age_group = factor(age_group, levels = c("young", "old"))
  )

# Renombrar niveles para mejor visualización
levels(merged_pfs$age_group) <- c("young (≤63)", "old (>63)")

# ────────────────────────────────────────────────
# 4. Ajustar modelo de Cox para PFS
# ────────────────────────────────────────────────
surv_obj_pfs <- Surv(time = merged_pfs$PFS_time_months, event = merged_pfs$PFS_status)

cox_pfs_model <- coxph(surv_obj_pfs ~ response_TAC1 + sex + age_group, data = merged_pfs)

# ────────────────────────────────────────────────
# 5. Forest Plot para PFS
# ────────────────────────────────────────────────
ggforest(cox_pfs_model,
         data = merged_pfs,
         main = "Cox Model for Progression-Free Survival (PFS)",
         fontsize = 1.0,
         cpositions = c(0.02, 0.22, 0.4),
         refLabel = "Reference",
         noDigits = 2)

# Guardar la figura (opcional)
ggsave("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/Forest_Cox_PFS_Response_Sex_Age.png",
       width = 10, height = 8, dpi = 300)

```



### 3.2. Combine m6A machinery mutational status, m6A machinery expression levels and clinical variables into a machine learning classifier (LASSO, random forest) to predict immunotherapy response 

**Lasso**

```{r}

# Load libraries
library(glmnet)
library(tidyverse)
library(pROC)

# 1. Prepare clinical metadata
clinical_data <- clinical_data %>%
  mutate(
    Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
    Sample = gsub("\\.tsv$", "", Sample)
  )

metadata_model <- clinical_data %>%
  filter(response_TAC1 %in% c("responder", "non_responder")) %>%
  mutate(
    sex = factor(sex, levels = c("male", "female")),
    smoking_status = if_else(is.na(smoking_status), "Unknown", as.character(smoking_status)),
    smoking_status = factor(smoking_status, levels = c("Unknown", "never_smoker", "smoker", "former_smoker")),
    response_TAC1 = factor(response_TAC1, levels = c("non_responder", "responder"))
  ) %>%
  dplyr::select(Sample, response_TAC1, sex, smoking_status)

# 2. Prepare mutation data
mutation_df <- mutation_types_by_patient 
mutation_df$Sample <- mutation_df$Sample_clean
mutation_df$Sample_clean <- NULL

# 3. Prepare expression data
m6a_genes_expr <- intersect(rownames(rlog_mat), m6a_genes)
expr_df <- rlog_mat[m6a_genes_expr, ] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Sample")

full_data <- expr_df %>%
  left_join(metadata_model, by = "Sample") %>%
  left_join(mutation_df, by = "Sample") %>%
  mutate(
    Readers = case_when(
      is.na(Readers) ~ -1,
      Readers == TRUE ~ 1,
      Readers == FALSE ~ 0
    ),
    Writers = case_when(
      is.na(Writers) ~ -1,
      Writers == TRUE ~ 1,
      Writers == FALSE ~ 0
    ),
    Erasers = case_when(
      is.na(Erasers) ~ -1,
      Erasers == TRUE ~ 1,
      Erasers == FALSE ~ 0
    )
  )



# 5. Prepare input for LASSO
y <- as.numeric(full_data$response_TAC1) - 1  # 0/1

x <- model.matrix(response_TAC1 ~ . - Sample, data = full_data)[, -1]  # design matrix

# 6. Run LASSO
set.seed(123)
cvfit <- cv.glmnet(x, y, alpha = 1, family = "binomial", type.measure = "auc")
best_lambda <- cvfit$lambda.min

# 7. Predict and evaluate
pred_probs <- predict(cvfit, newx = x, s = best_lambda, type = "response")
roc_obj <- roc(y, as.vector(pred_probs))
auc_val <- auc(roc_obj)

# 8. Plot ROC and show results
print(paste("AUC =", round(auc_val, 3)))
plot(roc_obj, main = paste("LASSO ROC - AUC:", round(auc_val, 3)))

# 9. Show selected features
selected_features <- coef(cvfit, s = "lambda.min") %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column("Feature") %>%
  filter(s1 != 0)

print(selected_features)

```


```{r}
# Load libraries
library(glmnet)
library(tidyverse)
library(pROC)

# 1. Prepare clinical metadata
clinical_data <- clinical_data %>%
  mutate(
    Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
    Sample = gsub("\\.tsv$", "", Sample)
  )

metadata_model <- clinical_data %>%
  filter(response_TAC1 %in% c("responder", "non_responder")) %>%
  mutate(
    sex = factor(sex, levels = c("male", "female")),
    smoking_status = if_else(is.na(smoking_status), "Unknown", as.character(smoking_status)),
    smoking_status = factor(smoking_status, levels = c("Unknown", "never_smoker", "smoker", "former_smoker")),
    response_TAC1 = factor(response_TAC1, levels = c("non_responder", "responder"))
  ) %>%
  dplyr::select(Sample, response_TAC1, sex, smoking_status)

# 2. Prepare mutation data
mutation_df <- mutation_types_by_patient
mutation_df$Sample <- mutation_df$Sample_clean
mutation_df$Sample_clean <- NULL

# 3. Prepare expression data
m6a_genes_expr <- intersect(rownames(rlog_mat), m6a_genes)
expr_df <- rlog_mat[m6a_genes_expr, ] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Sample")

# 4. Merge all data and encode mutations
full_data <- expr_df %>%
  left_join(metadata_model, by = "Sample") %>%
  left_join(mutation_df, by = "Sample") %>%
  mutate(
    Readers = case_when(
      is.na(Readers) ~ -1,
      Readers == TRUE ~ 1,
      Readers == FALSE ~ 0
    ),
    Writers = case_when(
      is.na(Writers) ~ -1,
      Writers == TRUE ~ 1,
      Writers == FALSE ~ 0
    ),
    Erasers = case_when(
      is.na(Erasers) ~ -1,
      Erasers == TRUE ~ 1,
      Erasers == FALSE ~ 0
    )
  )

# 5. Prepare input for LASSO
y <- as.numeric(full_data$response_TAC1) - 1  # Convert factor to binary 0/1

x <- model.matrix(response_TAC1 ~ . - Sample, data = full_data)[, -1]  # Design matrix

# 6. Run cross-validated LASSO
set.seed(123)
cvfit <- cv.glmnet(x, y, alpha = 1, family = "binomial", type.measure = "auc")
best_lambda <- cvfit$lambda.min

# 7. Predict and evaluate model
pred_probs <- predict(cvfit, newx = x, s = best_lambda, type = "response")
roc_obj <- roc(y, as.vector(pred_probs))
auc_val <- auc(roc_obj)
cat("AUC =", round(auc_val, 3), "\n")

# 8. Save ROC plot
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/LASSO_ROC.png", width = 800, height = 600)
plot(roc_obj, main = paste("LASSO ROC - AUC:", round(auc_val, 3)))
dev.off()

# 9. Save cross-validation plot
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/LASSO_CVPlot.png", width = 800, height = 600)
plot(cvfit)
dev.off()

# 10. Extract and save selected features
selected_features <- coef(cvfit, s = "lambda.min") %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column("Feature") %>%
  filter(s1 != 0) %>%
  arrange(desc(abs(s1))) %>%
  rename(Coefficient = s1)

write.csv(selected_features, "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/LASSO_Selected_Features.csv", row.names = FALSE)
print(selected_features)

# 11. Optional: show confusion matrix
pred_class <- ifelse(pred_probs > 0.5, 1, 0)
conf_mat <- table(True = y, Predicted = pred_class)
print(conf_mat)

```



random forests can handle extremely large datasets, where the so-called "curse of 
dimensionality" might cause other models to fail. At the same time, its error rates for most learning tasks are on par with nearly any other method.

Strengths
 • An all-purpose model that performs 
well on most problems
 • Can handle noisy or missing data 
as well as categorical or continuous 
features
 • Selects only the most important 
features


 Weaknesses
 • Unlike a decision tree, the model is 
not easily interpretable
 • May require some work to tune the 
model to the data
 • Can be used on data with an 
extremely large number of features 
or examples

**Preparacion de los datos**

```{r}
# ────────────────────────────────────────────────
# 1. Combine expression, mutation, clinical data
# ────────────────────────────────────────────────

# cargamos los datos

clinical_data_path <- "D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/20250228_DDBB_clinicos_RENAL_summarized.txt"
clinical_data <- fread(clinical_data_path, sep = "\t", header = TRUE)

epitranscriptomic_genes <- fread("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/epitranscriptomic_regulators_annotated.txt", 
                                 sep = "\t", header = TRUE)
m6a_genes <- epitranscriptomic_genes %>%
  filter(Mark == "m6A") %>%
  pull(Gene_symbol)
mutation_status <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM.txt",
                              sep = "\t", header = TRUE)


# Subset: responders & non-responders only
metadata <- clinical_data %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample)) %>%
  filter(response_TAC1 %in% c("responder", "non_responder")) %>%
  dplyr::select(Sample, response_TAC1, sex, age, stage)

# Normalize response variable
metadata$response_TAC1 <- factor(metadata$response_TAC1, levels = c("non_responder", "responder"))

# Prepare expression matrix: only m6A genes, only samples in metadata
expr_df <- as.data.frame(t(rlog_mat))
expr_df$Sample <- rownames(expr_df)
expr_m6a <- expr_df %>%
  dplyr::select(all_of(m6a_genes), Sample)

# Prepare mutational status (binary)
mutation_status <- read.table("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Protein_effect_annotation_KM.txt", sep = "\t", header = TRUE)
mutation_status <- mutation_status %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", Sample),
         Sample = gsub("\\.tsv$", "", Sample)) %>%
  filter(Mutational_Status %in% c("Protein_Effect_Mutation", "Non_Protein_Effect_Mutation")) %>%
  mutate(Protein_Effect = ifelse(Mutational_Status == "Protein_Effect_Mutation", 1, 0)) %>%
  dplyr::select(Sample, Protein_Effect, writer = Writter, reader = Reader, eraser = Eraser)

# Convert writer/reader/eraser to binary
mutation_status <- mutation_status %>%
  mutate(writer = ifelse(writer == "Writter", 1, 0),
         reader = ifelse(reader == "Reader", 1, 0),
         eraser = ifelse(eraser == "Eraser", 1, 0))

# Combine all
merged_data <- metadata %>%
  left_join(expr_m6a, by = "Sample") %>%
  left_join(mutation_status, by = "Sample") %>%
  na.omit()

```

```{r}
# ─────────────────────────────────────────────────────
# 1. Cargar librerías necesarias
# ─────────────────────────────────────────────────────
library(randomForest)
library(pROC)
library(dplyr)

# ─────────────────────────────────────────────────────
# 2. Preparar matriz de expresión media por gen m6A
# ─────────────────────────────────────────────────────
# Filtrar solo los genes m6A y hacer media por muestra (si quieres usar todos, omite esta parte)
m6a_expression <- t(rlog_mat[m6a_genes[m6a_genes %in% rownames(rlog_mat)], ])
m6a_expression_df <- as.data.frame(m6a_expression)
m6a_expression_df$Sample <- rownames(m6a_expression_df)

# ─────────────────────────────────────────────────────
# 3. Unir todo en un solo dataset
# ─────────────────────────────────────────────────────
model_data <- metadata %>%
  inner_join(mutation_status, by = "Sample") %>%
  inner_join(m6a_expression_df, by = "Sample")

# Eliminar NAs
model_data <- model_data %>% na.omit()

# ─────────────────────────────────────────────────────
# 4. Preparar variables
# ─────────────────────────────────────────────────────
# Variable de respuesta
response <- model_data$response_TAC1

# Variables predictoras (quitar columnas no numéricas excepto respuesta)
predictors <- model_data %>%
  dplyr::select(-Sample, -response_TAC1)

# Asegurarse que respuesta es factor binario
response <- factor(response, levels = c("non_responder", "responder"))

# ─────────────────────────────────────────────────────
# 5. Entrenar modelo Random Forest
# ─────────────────────────────────────────────────────
set.seed(123)
rf_model <- randomForest(x = predictors, y = response, importance = TRUE, ntree = 500)


# Ver resumen del modelo
print(rf_model)

# ─────────────────────────────────────────────────────
# 6. Predicciones y AUC
# ─────────────────────────────────────────────────────
rf_probs <- predict(rf_model, type = "prob")[, 2]
roc_obj <- roc(response, rf_probs)

# AUC
auc_val <- auc(roc_obj)
print(paste("AUC:", round(auc_val, 3)))

# ─────────────────────────────────────────────────────
# 7. Visualizar curva ROC
# ─────────────────────────────────────────────────────
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/RF_1_AUC.png", width = 800, height = 600)
plot(roc_obj, col = "darkblue", lwd = 2, main = "ROC Curve - Random Forest")
legend("bottomright", legend = paste("AUC =", round(auc_val, 3)), col = "darkblue", lwd = 2)
dev.off()


```
	
	
	
```{r}
# ───────────────────────────────────────────────────────────────
# 1. Cargar librerías necesarias
# ───────────────────────────────────────────────────────────────
library(dplyr)
library(randomForest)
library(pROC)
library(tibble)

# ───────────────────────────────────────────────────────────────
# 2. PREPARAR DATOS CLÍNICOS
# ───────────────────────────────────────────────────────────────
# Crear Sample limpio para hacer joins
clinical_data <- clinical_data %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample)) %>%
  mutate(smoking_status = ifelse(smoking_status == "" | is.na(smoking_status), "Unknown", smoking_status),
         sex = ifelse(sex == "" | is.na(sex), "Unknown", sex)) %>%
  mutate(smoking_status = factor(smoking_status),
         sex = factor(sex))

# Filtrar solo los pacientes que tengan respuesta (R o NR)
metadata_model <- clinical_data %>%
  filter(response_TAC1 %in% c("responder", "non_responder")) %>%
  dplyr::select(Sample, response_TAC1, sex, smoking_status)

# ───────────────────────────────────────────────────────────────
# 3. EXPRESIÓN DE GENES m6A
# ───────────────────────────────────────────────────────────────
# Subconjunto de genes m6A presentes en rlog_mat
genes_m6a_validos <- m6a_genes[m6a_genes %in% rownames(rlog_mat)]

# Crear dataframe con expresión de genes m6A
expression_df <- t(rlog_mat[genes_m6a_validos, ])
expression_df <- as.data.frame(expression_df)
expression_df$Sample <- rownames(expression_df)

# ───────────────────────────────────────────────────────────────
# 4. COMBINAR DATOS
# ───────────────────────────────────────────────────────────────
model_data <- metadata_model %>%
  left_join(expression_df, by = "Sample") %>%
  na.omit()  # quitar NAs si algún paciente no tiene expresión

# ───────────────────────────────────────────────────────────────
# 5. PREPARAR VARIABLES PARA RANDOM FOREST
# ───────────────────────────────────────────────────────────────
# Variable respuesta
model_data$response <- factor(model_data$response_TAC1, levels = c("non_responder", "responder"))

# Variables predictoras
predictors <- model_data %>%
  dplyr::select(-Sample, -response_TAC1, -response)

# Convertir variables categóricas a dummy si es necesario
predictors$sex <- as.factor(predictors$sex)
predictors$smoking_status <- as.factor(predictors$smoking_status)

# ───────────────────────────────────────────────────────────────
# 6. RANDOM FOREST
# ───────────────────────────────────────────────────────────────
set.seed(123)
rf_model <- randomForest(x = predictors, y = model_data$response, ntree = 500, importance = TRUE)

# Resumen del modelo
print(rf_model)

# ───────────────────────────────────────────────────────────────
# 7. PREDICCIONES Y AUC
# ───────────────────────────────────────────────────────────────
rf_probs <- predict(rf_model, type = "prob")[, 2]
roc_obj <- roc(model_data$response, rf_probs)

# AUC
auc_val <- auc(roc_obj)
cat("AUC:", round(auc_val, 3), "\n")

# ───────────────────────────────────────────────────────────────
# 8. CURVA ROC
# ───────────────────────────────────────────────────────────────
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/RF_2_AUC.png", width = 800, height = 600)
plot(roc_obj, col = "darkblue", lwd = 2, main = "ROC Curve - Random Forest")
legend("bottomright", legend = paste("AUC =", round(auc_val, 3)), col = "darkblue", lwd = 2)
dev.off()
summary(rf_model)

```
	
	
	
```{r}
# 1. Cargar clinical_data y normalizar Sample IDs
clinical_data <- clinical_data %>%
  mutate(Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
         Sample = gsub("\\.tsv$", "", Sample))

# 2. Preparar metadata_model con clinical variables
metadata_model <- clinical_data %>%
  filter(response_TAC1 %in% c("responder", "non_responder")) %>%
  mutate(
    sex = factor(sex, levels = c("male", "female")),
    smoking_status = na_if(smoking_status, "Unknown"),
    response_TAC1 = factor(response_TAC1, levels = c("non_responder", "responder")),
    Sample = gsub("^htseq-RNA_FFPE_", "", sample_ID),
    Sample = gsub("\\.tsv$", "", Sample)
  ) %>%
  dplyr::select(Sample, response_TAC1, sex, smoking_status)

# 3. Preparar expresión normalizada de genes m6A
expr_matrix <- as.data.frame(t(rlog_mat[rownames(rlog_mat) %in% m6a_genes, ]))
expr_matrix$Sample <- rownames(expr_matrix)
expression_df <- expr_matrix

# 4. Preparar tabla de mutaciones por paciente (reader, writer, eraser)
mutation_types_by_patient <- mutation_types_by_patient %>%
  rownames_to_column("Sample")  # asegurarse de tener columna Sample

# 5. Unir todas las fuentes
model_data <- metadata_model %>%
  left_join(mutation_types_by_patient, by = "Sample") %>%
  left_join(expression_df, by = "Sample")

# 6. Convertir columnas Reader, Writer, Eraser a variables numéricas (NA para no WES)
model_data <- model_data %>%
  mutate(
    reader = ifelse(is.na(Readers), NA, as.numeric(Readers)),
    writer = ifelse(is.na(Writers), NA, as.numeric(Writers)),
    eraser = ifelse(is.na(Erasers), NA, as.numeric(Erasers))
  ) %>%
  dplyr::select(-Readers, -Writers, -Erasers)


# ───────────────────────────────────────────────────────────────
# 6. RANDOM FOREST
# ───────────────────────────────────────────────────────────────
set.seed(123)
rf_model <- randomForest(x = predictors, y = model_data$response, ntree = 500, importance = TRUE)

# Resumen del modelo
print(rf_model)

# ───────────────────────────────────────────────────────────────
# 7. PREDICCIONES Y AUC
# ───────────────────────────────────────────────────────────────
rf_probs <- predict(rf_model, type = "prob")[, 2]
roc_obj <- roc(model_data$response, rf_probs)

# AUC
auc_val <- auc(roc_obj)
cat("AUC:", round(auc_val, 3), "\n")

# ───────────────────────────────────────────────────────────────
# 8. CURVA ROC
# ───────────────────────────────────────────────────────────────
png("D:/didic/Documents/Documentos/Master UOC/Cuatri 2/TFM/Fotos/RF_3_AUC.png", width = 800, height = 600)
plot(roc_obj, col = "darkblue", lwd = 2, main = "ROC Curve - Random Forest")
legend("bottomright", legend = paste("AUC =", round(auc_val, 3)), col = "darkblue", lwd = 2)
dev.off()

```
	

	
	
	
	
	
	
	
	
	
	
	
	